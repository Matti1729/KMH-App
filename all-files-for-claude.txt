import React, { useState, useEffect, useMemo } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, TextInput, Modal, Image, Platform, Linking, Pressable } from 'react-native';
import { supabase } from '../../config/supabase';
import { Sidebar } from '../../components/Sidebar';

const POSITIONS = ['TW', 'IV', 'LV', 'RV', 'DM', 'ZM', 'OM', 'LA', 'RA', 'ST'];

const SCOUTING_STATUS = [
  { id: 'gesichtet', label: 'Gesichtet', color: '#10b981' },
  { id: 'in_beobachtung', label: 'In Beobachtung', color: '#f59e0b' },
  { id: 'kontaktiert', label: 'Kontaktiert', color: '#3b82f6' },
];

const LISTINGS = ['Karl Herzog Sportmanagement', 'PM Sportmanagement'];

// Local Transfermarkt logo
const TransfermarktLogo = require('../../../assets/transfermarkt-logo.png');

interface ScoutedPlayer {
  id: string; first_name: string; last_name: string; birth_date: string; position: string;
  club: string; rating: number; scout_id: string; scout_name?: string;
  status: string; notes: string; created_at: string; photo_url?: string;
  transfermarkt_url?: string; agent_name?: string; agent_updated_at?: string;
  phone?: string; additional_info?: string;
  current_status?: string; // IST-Stand Freitext
  archived?: boolean; archived_at?: string; archive_reason?: string;
}

// Helper to parse positions (stored as comma-separated string)
const parsePositions = (pos: string): string[] => {
  if (!pos) return [];
  return pos.split(',').map(p => p.trim()).filter(p => p.length > 0);
};

const formatPositions = (positions: string[]): string => {
  return positions.join(', ');
};

interface ScoutingGame {
  id: string; date: string; home_team: string; away_team: string; 
  location: string; scout_id: string; scout_name?: string; notes: string; created_at: string;
}

interface Advisor { id: string; first_name: string; last_name: string; }

type ViewMode = 'kanban' | 'liste' | 'archiv';
type ActiveTab = 'spieler' | 'spiele';

const getYearFromDate = (dateStr: string): string => {
  if (!dateStr) return '';
  if (dateStr.length === 4) return dateStr;
  const parts = dateStr.split('-');
  return parts[0] || '';
};

const formatBirthDisplay = (dateStr: string): string => {
  if (!dateStr) return '-';
  if (dateStr.length === 4) return `Jg. ${dateStr}`;
  try {
    const date = new Date(dateStr);
    return date.toLocaleDateString('de-DE');
  } catch {
    return dateStr;
  }
};

// Function to fetch agent from Transfermarkt (via proxy/scraping service)
const fetchAgentFromTransfermarkt = async (transfermarktUrl: string): Promise<string | null> => {
  if (!transfermarktUrl) return null;
  
  try {
    // Use a CORS proxy for web or direct fetch for native
    const proxyUrl = Platform.OS === 'web' 
      ? `https://api.allorigins.win/raw?url=${encodeURIComponent(transfermarktUrl)}`
      : transfermarktUrl;
    
    const response = await fetch(proxyUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    if (!response.ok) return null;
    
    const html = await response.text();
    
    // Parse agent from HTML - Transfermarkt shows agent in a specific section
    // Look for "Spielerberater:" or "Agent:" pattern
    const agentPatterns = [
      /Spielerberater:<\/span>\s*<[^>]+>([^<]+)</i,
      /Berater:<\/span>\s*<[^>]+>([^<]+)</i,
      /data-agent[^>]*>([^<]+)</i,
      /"agent":\s*"([^"]+)"/i,
      /class="[^"]*agent[^"]*"[^>]*>([^<]+)</i,
    ];
    
    for (const pattern of agentPatterns) {
      const match = html.match(pattern);
      if (match && match[1]) {
        const agent = match[1].trim();
        if (agent && agent.length > 1 && agent !== '-') {
          return agent;
        }
      }
    }
    
    return null;
  } catch (error) {
    console.error('Error fetching agent from Transfermarkt:', error);
    return null;
  }
};

export function ScoutingScreen({ navigation }: any) {
  const [activeTab, setActiveTab] = useState<ActiveTab>('spieler');
  const [viewMode, setViewMode] = useState<ViewMode>('kanban');
  const [scoutedPlayers, setScoutedPlayers] = useState<ScoutedPlayer[]>([]);
  const [scoutingGames, setScoutingGames] = useState<ScoutingGame[]>([]);
  const [advisors, setAdvisors] = useState<Advisor[]>([]);
  const [clubLogos, setClubLogos] = useState<Record<string, string>>({});
  const [clubNames, setClubNames] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);
  const [currentUserName, setCurrentUserName] = useState<string>('');

  const [searchText, setSearchText] = useState('');
  const [selectedPositions, setSelectedPositions] = useState<string[]>([]);
  const [selectedYears, setSelectedYears] = useState<string[]>([]);
  const [selectedRatings, setSelectedRatings] = useState<number[]>([]);
  const [showPositionDropdown, setShowPositionDropdown] = useState(false);
  const [showYearDropdown, setShowYearDropdown] = useState(false);
  const [showRatingDropdown, setShowRatingDropdown] = useState(false);

  const [showAddPlayerModal, setShowAddPlayerModal] = useState(false);
  const [showAddGameModal, setShowAddGameModal] = useState(false);
  const [showPlayerDetailModal, setShowPlayerDetailModal] = useState(false);
  const [selectedPlayer, setSelectedPlayer] = useState<ScoutedPlayer | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [editData, setEditData] = useState<Partial<ScoutedPlayer>>({});
  const [fetchingAgent, setFetchingAgent] = useState(false);

  // Entscheidungs-Modal State
  const [showDecisionModal, setShowDecisionModal] = useState(false);
  const [showArchiveModal, setShowArchiveModal] = useState(false);
  const [showTransferModal, setShowTransferModal] = useState(false);
  const [archiveReason, setArchiveReason] = useState('');
  const [transferListing, setTransferListing] = useState('');
  const [transferResponsibility, setTransferResponsibility] = useState('');

  const [clubSearchText, setClubSearchText] = useState('');
  const [showClubDropdown, setShowClubDropdown] = useState(false);
  const [editClubSearchText, setEditClubSearchText] = useState('');
  const [showEditClubDropdown, setShowEditClubDropdown] = useState(false);

  const [newPlayer, setNewPlayer] = useState({
    first_name: '', last_name: '', birth_date: '2005', position: 'ST',
    club: '', rating: 5, notes: '', status: 'gesichtet', photo_url: '', 
    transfermarkt_url: '', agent_name: '', phone: '', additional_info: '', current_status: ''
  });
  const [newPlayerClubSearch, setNewPlayerClubSearch] = useState('');
  const [showNewPlayerClubDropdown, setShowNewPlayerClubDropdown] = useState(false);

  const [newGame, setNewGame] = useState({
    date: '', home_team: '', away_team: '', location: '', notes: ''
  });

  const [draggedPlayerId, setDraggedPlayerId] = useState<string | null>(null);
  const [dragOverStatus, setDragOverStatus] = useState<string | null>(null);

  const availableYears = useMemo(() => {
    const years = new Set<string>();
    scoutedPlayers.forEach(p => {
      const year = getYearFromDate(p.birth_date);
      if (year) years.add(year);
    });
    return Array.from(years).sort((a, b) => b.localeCompare(a));
  }, [scoutedPlayers]);

  const availablePositions = useMemo(() => {
    const positions = new Set<string>();
    scoutedPlayers.forEach(p => {
      if (p.position) positions.add(p.position);
    });
    return POSITIONS.filter(p => positions.has(p));
  }, [scoutedPlayers]);

  useEffect(() => {
    fetchCurrentUser(); fetchScoutedPlayers(); fetchScoutingGames(); fetchAdvisors(); fetchClubLogos();
  }, []);

  useEffect(() => {
    if (Platform.OS !== 'web') return;
    const handleGlobalDragEnd = () => {
      setDraggedPlayerId(null);
      setDragOverStatus(null);
    };
    document.addEventListener('dragend', handleGlobalDragEnd);
    return () => document.removeEventListener('dragend', handleGlobalDragEnd);
  }, []);

  // Auto-update agent when player modal opens
  useEffect(() => {
    if (selectedPlayer && selectedPlayer.transfermarkt_url && showPlayerDetailModal) {
      checkAndUpdateAgent(selectedPlayer);
    }
  }, [selectedPlayer?.id, showPlayerDetailModal]);

  const checkAndUpdateAgent = async (player: ScoutedPlayer) => {
    if (!player.transfermarkt_url) return;
    
    // Check if we should update (once per day max)
    const lastUpdate = player.agent_updated_at ? new Date(player.agent_updated_at) : null;
    const now = new Date();
    const hoursSinceUpdate = lastUpdate ? (now.getTime() - lastUpdate.getTime()) / (1000 * 60 * 60) : 999;
    
    if (hoursSinceUpdate < 24) return; // Don't update more than once per day
    
    setFetchingAgent(true);
    const agent = await fetchAgentFromTransfermarkt(player.transfermarkt_url);
    setFetchingAgent(false);
    
    if (agent && agent !== player.agent_name) {
      // Update in database
      const { error } = await supabase
        .from('scouted_players')
        .update({ agent_name: agent, agent_updated_at: now.toISOString() })
        .eq('id', player.id);
      
      if (!error) {
        // Update local state
        const updated = { ...player, agent_name: agent, agent_updated_at: now.toISOString() };
        setScoutedPlayers(prev => prev.map(p => p.id === player.id ? updated : p));
        setSelectedPlayer(updated);
      }
    } else if (!agent && player.agent_name) {
      // Agent was removed or not found, keep existing
    } else {
      // Just update the timestamp
      await supabase
        .from('scouted_players')
        .update({ agent_updated_at: now.toISOString() })
        .eq('id', player.id);
    }
  };

  const fetchCurrentUser = async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      setCurrentUserId(user.id);
      const { data: advisor } = await supabase.from('advisors').select('first_name, last_name').eq('id', user.id).single();
      if (advisor) setCurrentUserName(`${advisor.first_name} ${advisor.last_name}`);
    }
  };

  // Migration: Alte Status-Werte in neue umwandeln
  const migrateOldStatus = async () => {
    const statusMapping: Record<string, string> = {
      'zu_kontaktieren': 'in_beobachtung',
      'in_kontakt': 'kontaktiert',
      'archiviert': 'gesichtet', // Archivierte Spieler bekommen Status gesichtet + archived=true
    };

    for (const [oldStatus, newStatus] of Object.entries(statusMapping)) {
      // Pr√ºfe ob es Spieler mit altem Status gibt
      const { data } = await supabase
        .from('scouted_players')
        .select('id, status')
        .eq('status', oldStatus);
      
      if (data && data.length > 0) {
        console.log(`Migriere ${data.length} Spieler von "${oldStatus}" zu "${newStatus}"`);
        
        if (oldStatus === 'archiviert') {
          // Archivierte Spieler: Status auf gesichtet + archived=true
          await supabase
            .from('scouted_players')
            .update({ status: newStatus, archived: true })
            .eq('status', oldStatus);
        } else {
          await supabase
            .from('scouted_players')
            .update({ status: newStatus })
            .eq('status', oldStatus);
        }
      }
    }
  };

  const fetchScoutedPlayers = async () => {
    setLoading(true);
    
    // Erst Migration durchf√ºhren
    await migrateOldStatus();
    
    const { data, error } = await supabase.from('scouted_players').select('*').order('created_at', { ascending: false });
    if (!error && data) {
      const scoutIds = [...new Set(data.map(p => p.scout_id).filter(Boolean))];
      if (scoutIds.length > 0) {
        const { data: scouts } = await supabase.from('advisors').select('id, first_name, last_name').in('id', scoutIds);
        const scoutMap: Record<string, string> = {};
        scouts?.forEach(s => scoutMap[s.id] = `${s.first_name} ${s.last_name}`);
        setScoutedPlayers(data.map(p => ({ ...p, scout_name: scoutMap[p.scout_id] || 'Unbekannt' })));
      } else {
        setScoutedPlayers(data);
      }
    }
    setLoading(false);
  };

  const fetchScoutingGames = async () => {
    const { data, error } = await supabase.from('scouting_games').select('*').order('date', { ascending: true });
    if (!error && data) {
      const scoutIds = [...new Set(data.map(g => g.scout_id).filter(Boolean))];
      if (scoutIds.length > 0) {
        const { data: scouts } = await supabase.from('advisors').select('id, first_name, last_name').in('id', scoutIds);
        const scoutMap: Record<string, string> = {};
        scouts?.forEach(s => scoutMap[s.id] = `${s.first_name} ${s.last_name}`);
        setScoutingGames(data.map(g => ({ ...g, scout_name: scoutMap[g.scout_id] || 'Unbekannt' })));
      } else {
        setScoutingGames(data);
      }
    }
  };

  const fetchAdvisors = async () => {
    const { data } = await supabase.from('advisors').select('id, first_name, last_name').order('last_name');
    if (data) setAdvisors(data);
  };

  const fetchClubLogos = async () => {
    const { data } = await supabase.from('club_logos').select('club_name, logo_url');
    if (data) {
      const logoMap: Record<string, string> = {};
      const names: string[] = [];
      data.forEach(item => { logoMap[item.club_name] = item.logo_url; names.push(item.club_name); });
      setClubLogos(logoMap);
      setClubNames(names.sort());
    }
  };

  const getClubLogo = (clubName: string): string | null => {
    if (!clubName) return null;
    if (clubLogos[clubName]) return clubLogos[clubName];
    for (const [logoClub, logoUrl] of Object.entries(clubLogos)) {
      if (clubName.toLowerCase().includes(logoClub.toLowerCase()) || logoClub.toLowerCase().includes(clubName.toLowerCase())) return logoUrl;
    }
    return null;
  };

  const getFilteredClubs = (searchTxt: string) => {
    if (!searchTxt || searchTxt.length === 0) return [];
    return clubNames
      .filter(name => {
        // Filter out 2. Mannschaften, U23, U21, II, B-Team etc.
        const lowerName = name.toLowerCase();
        if (lowerName.includes(' ii') || lowerName.includes(' 2') || lowerName.includes(' b')) return false;
        if (lowerName.includes('u23') || lowerName.includes('u21') || lowerName.includes('u19')) return false;
        if (lowerName.includes('reserve') || lowerName.includes('amateur')) return false;
        return name.toLowerCase().includes(searchTxt.toLowerCase());
      })
      .slice(0, 10);
  };

  const addScoutedPlayer = async () => {
    if (!newPlayer.first_name || !newPlayer.last_name || !currentUserId) return;
    
    // Duplikat-Pr√ºfung: Pr√ºfe in scouted_players und player_details
    const firstName = newPlayer.first_name.trim().toLowerCase();
    const lastName = newPlayer.last_name.trim().toLowerCase();
    
    // Pr√ºfe in Scouting
    const { data: scoutingDuplicates } = await supabase
      .from('scouted_players')
      .select('id, first_name, last_name, club')
      .ilike('first_name', firstName)
      .ilike('last_name', lastName);
    
    // Pr√ºfe in Spieler√ºbersicht
    const { data: playerDuplicates } = await supabase
      .from('player_details')
      .select('id, first_name, last_name, club')
      .ilike('first_name', firstName)
      .ilike('last_name', lastName);
    
    const hasDuplicates = (scoutingDuplicates && scoutingDuplicates.length > 0) || (playerDuplicates && playerDuplicates.length > 0);
    
    if (hasDuplicates) {
      let message = `Ein Spieler mit dem Namen "${newPlayer.first_name} ${newPlayer.last_name}" existiert bereits:\n\n`;
      
      if (scoutingDuplicates && scoutingDuplicates.length > 0) {
        message += 'üìã In Scouting:\n';
        scoutingDuplicates.forEach(p => {
          message += `  ‚Ä¢ ${p.first_name} ${p.last_name}${p.club ? ` (${p.club})` : ''}\n`;
        });
      }
      
      if (playerDuplicates && playerDuplicates.length > 0) {
        message += '\nüë• In Spieler√ºbersicht:\n';
        playerDuplicates.forEach(p => {
          message += `  ‚Ä¢ ${p.first_name} ${p.last_name}${p.club ? ` (${p.club})` : ''}\n`;
        });
      }
      
      message += '\nTrotzdem anlegen?';
      
      const confirmAdd = window.confirm(message);
      if (!confirmAdd) return;
    }
    
    // Try to fetch agent if transfermarkt URL is provided
    let agentName = newPlayer.agent_name;
    if (newPlayer.transfermarkt_url && !agentName) {
      const fetchedAgent = await fetchAgentFromTransfermarkt(newPlayer.transfermarkt_url);
      if (fetchedAgent) agentName = fetchedAgent;
    }
    
    const playerData = {
      ...newPlayer,
      agent_name: agentName,
      agent_updated_at: newPlayer.transfermarkt_url ? new Date().toISOString() : null,
      scout_id: currentUserId
    };
    
    const { error } = await supabase.from('scouted_players').insert(playerData);
    if (!error) {
      setShowAddPlayerModal(false);
      setNewPlayer({ first_name: '', last_name: '', birth_date: '2005', position: 'ST', club: '', rating: 5, notes: '', status: 'gesichtet', photo_url: '', transfermarkt_url: '', agent_name: '', phone: '', additional_info: '', current_status: '' });
      setNewPlayerClubSearch('');
      fetchScoutedPlayers();
    }
  };

  const updateScoutedPlayer = async () => {
    if (!selectedPlayer || !editData) return;
    
    // Check if transfermarkt URL changed and fetch new agent
    let agentName = editData.agent_name;
    if (editData.transfermarkt_url && editData.transfermarkt_url !== selectedPlayer.transfermarkt_url) {
      const fetchedAgent = await fetchAgentFromTransfermarkt(editData.transfermarkt_url);
      if (fetchedAgent) agentName = fetchedAgent;
    }
    
    const updatePayload = {
      first_name: editData.first_name,
      last_name: editData.last_name,
      birth_date: editData.birth_date,
      position: editData.position,
      club: editData.club,
      rating: editData.rating,
      status: editData.status,
      notes: editData.notes,
      photo_url: editData.photo_url,
      transfermarkt_url: editData.transfermarkt_url,
      agent_name: agentName,
      agent_updated_at: editData.transfermarkt_url ? new Date().toISOString() : null,
      phone: editData.phone,
      additional_info: editData.additional_info,
      current_status: editData.current_status,
    };
    
    const { error } = await supabase.from('scouted_players').update(updatePayload).eq('id', selectedPlayer.id);
    if (error) {
      console.error('Update error:', error);
      alert('Fehler beim Speichern: ' + error.message);
    } else {
      const updatedPlayer = { ...selectedPlayer, ...updatePayload };
      setScoutedPlayers(prev => prev.map(p => p.id === selectedPlayer.id ? updatedPlayer : p));
      setSelectedPlayer(updatedPlayer);
      setIsEditing(false);
      setShowEditClubDropdown(false);
    }
  };

  const addScoutingGame = async () => {
    if (!newGame.date || !newGame.home_team || !newGame.away_team || !currentUserId) return;
    const { error } = await supabase.from('scouting_games').insert({ ...newGame, scout_id: currentUserId });
    if (!error) {
      setShowAddGameModal(false);
      setNewGame({ date: '', home_team: '', away_team: '', location: '', notes: '' });
      fetchScoutingGames();
    }
  };

  const updatePlayerStatus = async (playerId: string, newStatus: string) => {
    const { error } = await supabase.from('scouted_players').update({ status: newStatus }).eq('id', playerId);
    if (!error) {
      setScoutedPlayers(prev => prev.map(p => p.id === playerId ? { ...p, status: newStatus } : p));
    }
  };

  const deleteScoutedPlayer = async (playerId: string) => {
    const { error } = await supabase.from('scouted_players').delete().eq('id', playerId);
    if (!error) { 
      setScoutedPlayers(prev => prev.filter(p => p.id !== playerId)); 
      setShowPlayerDetailModal(false); 
      setIsEditing(false);
    }
  };

  const deleteScoutingGame = async (gameId: string) => {
    const { error } = await supabase.from('scouting_games').delete().eq('id', gameId);
    if (!error) fetchScoutingGames();
  };

  // Archivierte Spieler z√§hlen
  const archivedPlayersCount = scoutedPlayers.filter(p => p.archived).length;

  // Aktive (nicht archivierte) Spieler filtern
  const activePlayers = scoutedPlayers.filter(p => !p.archived);
  const archivedPlayers = scoutedPlayers.filter(p => p.archived);

  const filteredPlayers = activePlayers.filter(p => {
    const matchesSearch = searchText === '' || 
      `${p.first_name} ${p.last_name}`.toLowerCase().includes(searchText.toLowerCase()) || 
      (p.club && p.club.toLowerCase().includes(searchText.toLowerCase()));
    const matchesPosition = selectedPositions.length === 0 || selectedPositions.includes(p.position);
    const matchesYear = selectedYears.length === 0 || selectedYears.includes(getYearFromDate(p.birth_date));
    const matchesRating = selectedRatings.length === 0 || selectedRatings.includes(p.rating);
    return matchesSearch && matchesPosition && matchesYear && matchesRating;
  });

  const getPlayersByStatus = (status: string) => filteredPlayers.filter(p => p.status === status);

  // Archivieren
  const archivePlayer = async () => {
    if (!selectedPlayer) return;
    const { error } = await supabase.from('scouted_players').update({
      archived: true,
      archived_at: new Date().toISOString(),
      archive_reason: archiveReason
    }).eq('id', selectedPlayer.id);
    
    if (!error) {
      setScoutedPlayers(prev => prev.map(p => 
        p.id === selectedPlayer.id ? { ...p, archived: true, archived_at: new Date().toISOString(), archive_reason: archiveReason } : p
      ));
      setShowArchiveModal(false);
      setShowDecisionModal(false);
      setShowPlayerDetailModal(false);
      setArchiveReason('');
    }
  };

  // Wiederherstellen
  const restorePlayer = async (playerId: string) => {
    const { error } = await supabase.from('scouted_players').update({
      archived: false,
      archived_at: null,
      archive_reason: null
    }).eq('id', playerId);
    
    if (!error) {
      setScoutedPlayers(prev => prev.map(p => 
        p.id === playerId ? { ...p, archived: false, archived_at: undefined, archive_reason: undefined } : p
      ));
    }
  };

  // In Spieler√ºbersicht √ºbernehmen
  const transferToPlayers = async () => {
    if (!selectedPlayer || !transferListing || !transferResponsibility) {
      alert('Bitte Listung und Zust√§ndigkeit ausw√§hlen');
      return;
    }

    // Duplikat-Pr√ºfung in player_details
    const firstName = selectedPlayer.first_name.trim().toLowerCase();
    const lastName = selectedPlayer.last_name.trim().toLowerCase();
    
    const { data: playerDuplicates } = await supabase
      .from('player_details')
      .select('id, first_name, last_name, club')
      .ilike('first_name', firstName)
      .ilike('last_name', lastName);
    
    if (playerDuplicates && playerDuplicates.length > 0) {
      let message = `Ein Spieler mit dem Namen "${selectedPlayer.first_name} ${selectedPlayer.last_name}" existiert bereits in der Spieler√ºbersicht:\n\n`;
      
      playerDuplicates.forEach(p => {
        message += `  ‚Ä¢ ${p.first_name} ${p.last_name}${p.club ? ` (${p.club})` : ''}\n`;
      });
      
      message += '\nTrotzdem √ºbernehmen?';
      
      const confirmAdd = window.confirm(message);
      if (!confirmAdd) return;
    }

    // Spieler in player_details-Tabelle einf√ºgen
    // birth_date: Falls nur Jahrgang (z.B. "2005"), nicht √ºbernehmen (null)
    let birthDate = selectedPlayer.birth_date;
    if (birthDate && birthDate.length === 4) {
      birthDate = null; // Nur Jahrgang - nicht √ºbernehmen
    }
    
    const playerData = {
      first_name: selectedPlayer.first_name,
      last_name: selectedPlayer.last_name,
      birth_date: birthDate || null,
      position: selectedPlayer.position,
      club: selectedPlayer.club,
      phone: selectedPlayer.phone,
      transfermarkt_url: selectedPlayer.transfermarkt_url,
      listing: transferListing,
      responsibility: transferResponsibility,
    };

    const { error: insertError } = await supabase.from('player_details').insert(playerData);
    
    if (insertError) {
      alert('Fehler beim √úbernehmen: ' + insertError.message);
      return;
    }

    // Spieler aus Scouting l√∂schen
    const { error: deleteError } = await supabase.from('scouted_players').delete().eq('id', selectedPlayer.id);
    
    if (!deleteError) {
      setScoutedPlayers(prev => prev.filter(p => p.id !== selectedPlayer.id));
      setShowTransferModal(false);
      setShowDecisionModal(false);
      setShowPlayerDetailModal(false);
      setTransferListing('');
      setTransferResponsibility('');
      alert(`${selectedPlayer.first_name} ${selectedPlayer.last_name} wurde in die Spieler√ºbersicht √ºbernommen!`);
    }
  };

  const togglePosition = (pos: string) => {
    setSelectedPositions(prev => prev.includes(pos) ? prev.filter(p => p !== pos) : [...prev, pos]);
  };

  const toggleYear = (year: string) => {
    setSelectedYears(prev => prev.includes(year) ? prev.filter(y => y !== year) : [...prev, year]);
  };

  const toggleRating = (rating: number) => {
    setSelectedRatings(prev => prev.includes(rating) ? prev.filter(r => r !== rating) : [...prev, rating]);
  };

  const clearPositions = () => setSelectedPositions([]);
  const clearYears = () => setSelectedYears([]);
  const clearRatings = () => setSelectedRatings([]);

  const onDragStart = (e: any, playerId: string) => {
    if (Platform.OS !== 'web') return;
    setDraggedPlayerId(playerId);
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', playerId);
    setTimeout(() => {
      const el = document.querySelector(`[data-player-id="${playerId}"]`);
      if (el) (el as HTMLElement).style.opacity = '0.4';
    }, 0);
  };

  const onDragEnd = () => {
    if (Platform.OS !== 'web') return;
    const el = document.querySelector(`[data-player-id="${draggedPlayerId}"]`);
    if (el) (el as HTMLElement).style.opacity = '1';
    setDraggedPlayerId(null);
    setDragOverStatus(null);
  };

  const onDragOver = (e: any, statusId: string) => {
    if (Platform.OS !== 'web') return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    if (dragOverStatus !== statusId) setDragOverStatus(statusId);
  };

  const onDragLeave = (e: any, statusId: string) => {
    if (Platform.OS !== 'web') return;
    const rect = e.currentTarget.getBoundingClientRect();
    const { clientX, clientY } = e;
    if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) {
      if (dragOverStatus === statusId) setDragOverStatus(null);
    }
  };

  const onDrop = async (e: any, targetStatus: string) => {
    if (Platform.OS !== 'web') return;
    e.preventDefault();
    const playerId = e.dataTransfer.getData('text/plain') || draggedPlayerId;
    if (playerId) {
      const player = scoutedPlayers.find(p => p.id === playerId);
      if (player && player.status !== targetStatus) {
        await updatePlayerStatus(playerId, targetStatus);
      }
    }
    setDraggedPlayerId(null);
    setDragOverStatus(null);
  };

  const openTransfermarkt = (url: string) => {
    if (Platform.OS === 'web') {
      window.open(url, '_blank');
    } else {
      Linking.openURL(url);
    }
  };

  const renderClubSelector = (
    searchTxt: string, setSearchTxt: (t: string) => void,
    showDrop: boolean, setShowDrop: (s: boolean) => void,
    onSelect: (c: string) => void
  ) => {
    const list = getFilteredClubs(searchTxt);
    return (
      <View style={styles.clubSelectorContainer}>
        <TextInput 
          style={styles.formInput} 
          value={searchTxt} 
          onChangeText={(t) => { setSearchTxt(t); onSelect(t); setShowDrop(t.length > 0 && getFilteredClubs(t).length > 0); }} 
          onFocus={() => { if (searchTxt.length > 0 && getFilteredClubs(searchTxt).length > 0) setShowDrop(true); }}
          onBlur={() => setTimeout(() => setShowDrop(false), 200)}
          placeholder="Verein suchen..." 
        />
        {showDrop && list.length > 0 && (
          <View style={styles.clubDropdown}>
            <ScrollView style={styles.clubDropdownScroll} nestedScrollEnabled keyboardShouldPersistTaps="handled">
              {list.map((club) => (
                <TouchableOpacity key={club} style={styles.clubDropdownItem} onPress={() => { setSearchTxt(club); onSelect(club); setShowDrop(false); }}>
                  {getClubLogo(club) && <Image source={{ uri: getClubLogo(club)! }} style={styles.clubDropdownLogo} />}
                  <Text style={styles.clubDropdownText}>{club}</Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>
        )}
      </View>
    );
  };

  const renderPlayerCard = (player: ScoutedPlayer) => {
    const isDragging = draggedPlayerId === player.id;
    
    const cardContent = (
      <TouchableOpacity 
        style={styles.cardContent}
        onPress={() => { 
          setSelectedPlayer(player); 
          setEditData({
            first_name: player.first_name, last_name: player.last_name, birth_date: player.birth_date,
            position: player.position, club: player.club, rating: player.rating, status: player.status,
            notes: player.notes, photo_url: player.photo_url, transfermarkt_url: player.transfermarkt_url,
            agent_name: player.agent_name, phone: player.phone, additional_info: player.additional_info,
            current_status: player.current_status,
          }); 
          setEditClubSearchText(player.club || ''); 
          setShowPlayerDetailModal(true); 
        }}
      >
        <View style={styles.cardHeader}>
          {getClubLogo(player.club) && <Image source={{ uri: getClubLogo(player.club)! }} style={styles.clubLogoCard} />}
          <View style={styles.cardInfo}>
            <Text style={styles.playerName}>{player.first_name} {player.last_name}</Text>
            <Text style={styles.playerYear}>Jg. {getYearFromDate(player.birth_date)}</Text>
          </View>
          <View style={styles.cardRight}>
            <View style={styles.positionBadgesRow}>
              {parsePositions(player.position).map((pos, idx) => (
                <View key={idx} style={styles.positionBadge}><Text style={styles.positionText}>{pos}</Text></View>
              ))}
            </View>
            <View style={styles.ratingBadgeCard}><Text style={styles.ratingTextCard}>‚≠ê {player.rating}/10</Text></View>
          </View>
        </View>
        {/* IST-Stand */}
        {player.current_status && (
          <View style={styles.currentStatusRow}>
            <Text style={styles.currentStatusText}>üí¨ {player.current_status}</Text>
          </View>
        )}
      </TouchableOpacity>
    );

    if (Platform.OS === 'web') {
      return (
        <div key={player.id} data-player-id={player.id} draggable onDragStart={(e) => onDragStart(e, player.id)} onDragEnd={onDragEnd}
          style={{ backgroundColor: '#fff', borderRadius: 10, marginBottom: 10, boxShadow: '0 2px 4px rgba(0,0,0,0.05)', cursor: 'grab', opacity: isDragging ? 0.4 : 1 }}>
          {cardContent}
        </div>
      );
    }
    return <View key={player.id} style={styles.playerCard}>{cardContent}</View>;
  };

  const renderKanbanColumn = (status: typeof SCOUTING_STATUS[0]) => {
    const players = getPlayersByStatus(status.id);
    const isDropTarget = dragOverStatus === status.id;
    
    if (Platform.OS === 'web') {
      return (
        <div key={status.id} onDragOver={(e) => onDragOver(e, status.id)} onDragLeave={(e) => onDragLeave(e, status.id)} onDrop={(e) => onDrop(e, status.id)}
          style={{ 
            width: 380, 
            backgroundColor: isDropTarget ? '#dbeafe' : '#f1f5f9', 
            borderRadius: 12, 
            marginRight: 16, 
            padding: 12, 
            border: isDropTarget ? '2px dashed #3b82f6' : '2px solid transparent', 
            transition: 'background-color 0.2s', 
            display: 'flex',
            flexDirection: 'column',
            maxHeight: 'calc(100vh - 250px)',
          }}>
          <View style={styles.kanbanHeader}>
            <View style={[styles.statusDot, { backgroundColor: status.color }]} />
            <Text style={styles.kanbanTitle}>{status.label}</Text>
            <View style={styles.countBadge}><Text style={styles.countText}>{players.length}</Text></View>
          </View>
          <div style={{ flex: 1, overflowY: 'scroll', paddingRight: 4 }}>
            {players.map(player => renderPlayerCard(player))}
          </div>
        </div>
      );
    }
    return (
      <View style={[styles.kanbanColumn, isDropTarget && styles.kanbanColumnDropTarget]} key={status.id}>
        <View style={styles.kanbanHeader}>
          <View style={[styles.statusDot, { backgroundColor: status.color }]} />
          <Text style={styles.kanbanTitle}>{status.label}</Text>
          <View style={styles.countBadge}><Text style={styles.countText}>{players.length}</Text></View>
        </View>
        <ScrollView style={styles.kanbanContent} showsVerticalScrollIndicator={false}>
          {players.map(player => renderPlayerCard(player))}
        </ScrollView>
      </View>
    );
  };

  const renderListView = () => (
    <View style={styles.tableContainer}>
      <View style={styles.tableHeader}>
        <Text style={[styles.tableHeaderCell, { flex: 1.6 }]}>Name</Text>
        <Text style={[styles.tableHeaderCell, { flex: 0.4 }]}>Geb.</Text>
        <Text style={[styles.tableHeaderCell, { flex: 0.8 }]}>Pos.</Text>
        <Text style={[styles.tableHeaderCell, { flex: 1.4 }]}>Verein</Text>
        <Text style={[styles.tableHeaderCell, { flex: 1.2 }]}>Berater</Text>
        <Text style={[styles.tableHeaderCell, { flex: 0.7 }]}>Rating</Text>
        <Text style={[styles.tableHeaderCell, { flex: 1 }]}>Scout</Text>
        <Text style={[styles.tableHeaderCell, { flex: 1.1 }]}>Status</Text>
        <Text style={[styles.tableHeaderCell, { flex: 0.3 }]}>TM</Text>
      </View>
      <ScrollView>
        {filteredPlayers.map(player => (
          <TouchableOpacity key={player.id} style={styles.tableRow} onPress={() => { 
            setSelectedPlayer(player); 
            setEditData({ first_name: player.first_name, last_name: player.last_name, birth_date: player.birth_date,
              position: player.position, club: player.club, rating: player.rating, status: player.status,
              notes: player.notes, photo_url: player.photo_url, transfermarkt_url: player.transfermarkt_url, 
              agent_name: player.agent_name, phone: player.phone, additional_info: player.additional_info,
              current_status: player.current_status }); 
            setEditClubSearchText(player.club || ''); 
            setShowPlayerDetailModal(true); 
          }}>
            <Text style={[styles.tableCell, styles.tableCellText, { flex: 1.6 }]}>{player.last_name}, {player.first_name}</Text>
            <Text style={[styles.tableCell, { flex: 0.4 }]}>{getYearFromDate(player.birth_date)}</Text>
            <View style={[styles.tableCell, { flex: 0.8, flexDirection: 'row', flexWrap: 'wrap', gap: 4 }]}>
              {parsePositions(player.position).map((pos, idx) => (
                <View key={idx} style={styles.positionBadgeSmall}><Text style={styles.positionTextSmall}>{pos}</Text></View>
              ))}
            </View>
            <Text style={[styles.tableCell, { flex: 1.4 }]} numberOfLines={1}>{player.club}</Text>
            <Text style={[styles.tableCell, { flex: 1.2 }]} numberOfLines={1}>{player.agent_name || '-'}</Text>
            <View style={[styles.tableCell, { flex: 0.7, flexDirection: 'row' }]}>
              <View style={styles.ratingBadgeList}><Text style={styles.ratingTextList}>‚≠ê {player.rating}/10</Text></View>
            </View>
            <Text style={[styles.tableCell, { flex: 1 }]} numberOfLines={1}>{player.scout_name}</Text>
            <Text style={[styles.tableCell, { flex: 1.1, color: SCOUTING_STATUS.find(s => s.id === player.status)?.color }]}>
              {SCOUTING_STATUS.find(s => s.id === player.status)?.label}
            </Text>
            <View style={[styles.tableCell, { flex: 0.3 }]}>
              {player.transfermarkt_url && (
                <TouchableOpacity onPress={(e) => { e.stopPropagation(); openTransfermarkt(player.transfermarkt_url!); }}>
                  <Image source={TransfermarktLogo} style={styles.tmLogoSmall} />
                </TouchableOpacity>
              )}
            </View>
          </TouchableOpacity>
        ))}
      </ScrollView>
    </View>
  );

  const renderGamesTab = () => (
    <View style={styles.gamesContainer}>
      <View style={styles.tableHeader}>
        <Text style={[styles.tableHeaderCell, { flex: 1 }]}>Datum</Text>
        <Text style={[styles.tableHeaderCell, { flex: 2 }]}>Spiel</Text>
        <Text style={[styles.tableHeaderCell, { flex: 1 }]}>Ort</Text>
        <Text style={[styles.tableHeaderCell, { flex: 1 }]}>Scout</Text>
        <Text style={[styles.tableHeaderCell, { flex: 0.5 }]}></Text>
      </View>
      <ScrollView>
        {scoutingGames.map(game => (
          <View key={game.id} style={styles.tableRow}>
            <Text style={[styles.tableCell, { flex: 1 }]}>{new Date(game.date).toLocaleDateString('de-DE')}</Text>
            <Text style={[styles.tableCell, { flex: 2, fontWeight: '600' }]}>{game.home_team} vs {game.away_team}</Text>
            <Text style={[styles.tableCell, { flex: 1 }]}>{game.location}</Text>
            <Text style={[styles.tableCell, { flex: 1 }]}>{game.scout_name}</Text>
            <TouchableOpacity style={[styles.tableCell, { flex: 0.5 }]} onPress={() => deleteScoutingGame(game.id)}><Text>üóëÔ∏è</Text></TouchableOpacity>
          </View>
        ))}
      </ScrollView>
    </View>
  );

  const renderArchivView = () => (
    <View style={styles.tableContainer}>
      <View style={styles.tableHeader}>
        <Text style={[styles.tableHeaderCell, { flex: 2 }]}>Name</Text>
        <Text style={[styles.tableHeaderCell, { flex: 0.5 }]}>Geb.</Text>
        <Text style={[styles.tableHeaderCell, { flex: 0.8 }]}>Pos.</Text>
        <Text style={[styles.tableHeaderCell, { flex: 1.5 }]}>Verein</Text>
        <Text style={[styles.tableHeaderCell, { flex: 2 }]}>Grund</Text>
        <Text style={[styles.tableHeaderCell, { flex: 1 }]}>Archiviert am</Text>
        <Text style={[styles.tableHeaderCell, { flex: 1 }]}></Text>
      </View>
      <ScrollView>
        {archivedPlayers.length === 0 ? (
          <View style={styles.emptyArchiv}>
            <Text style={styles.emptyArchivText}>Keine archivierten Spieler</Text>
          </View>
        ) : (
          archivedPlayers.map(player => (
            <View key={player.id} style={styles.tableRow}>
              <Text style={[styles.tableCell, styles.tableCellText, { flex: 2 }]}>{player.last_name}, {player.first_name}</Text>
              <Text style={[styles.tableCell, { flex: 0.5 }]}>{getYearFromDate(player.birth_date)}</Text>
              <Text style={[styles.tableCell, { flex: 0.8 }]}>{player.position}</Text>
              <Text style={[styles.tableCell, { flex: 1.5 }]}>{player.club}</Text>
              <Text style={[styles.tableCell, { flex: 2, color: '#64748b', fontStyle: 'italic' }]}>{player.archive_reason || '-'}</Text>
              <Text style={[styles.tableCell, { flex: 1 }]}>{player.archived_at ? new Date(player.archived_at).toLocaleDateString('de-DE') : '-'}</Text>
              <View style={[styles.tableCell, { flex: 1 }]}>
                <TouchableOpacity style={styles.restoreButton} onPress={() => restorePlayer(player.id)}>
                  <Text style={styles.restoreButtonText}>Wiederherstellen</Text>
                </TouchableOpacity>
              </View>
            </View>
          ))
        )}
      </ScrollView>
    </View>
  );

  const renderPlayerForm = (
    data: any, setData: (d: any) => void,
    clubSearch: string, setClubSearch: (t: string) => void,
    showClubDrop: boolean, setShowClubDrop: (s: boolean) => void
  ) => (
    <ScrollView style={{ maxHeight: 400 }} showsVerticalScrollIndicator={true} keyboardShouldPersistTaps="handled" nestedScrollEnabled>
      {/* Erste S√§ule: Grunddaten + Kontakt */}
      <View style={[styles.detailInfo, { zIndex: 9999 }]}>
        <View style={styles.formRow}>
          <View style={styles.formField}>
            <Text style={styles.formLabel}>Vorname *</Text>
            <TextInput style={styles.formInput} value={data.first_name} onChangeText={(t) => setData({...data, first_name: t})} placeholder="Vorname" />
          </View>
          <View style={styles.formField}>
            <Text style={styles.formLabel}>Nachname *</Text>
            <TextInput style={styles.formInput} value={data.last_name} onChangeText={(t) => setData({...data, last_name: t})} placeholder="Nachname" />
          </View>
        </View>
        <View style={[styles.formRow, { zIndex: 9999 }]}>
          <View style={[styles.formField, { zIndex: 9999 }]}>
            <Text style={styles.formLabel}>Verein</Text>
            {renderClubSelector(clubSearch, setClubSearch, showClubDrop, setShowClubDrop, (c) => setData({...data, club: c}))}
          </View>
          <View style={styles.formField}>
            <Text style={styles.formLabel}>Geburtsdatum / Jahrgang</Text>
            <TextInput style={styles.formInput} value={data.birth_date || ''} onChangeText={(t) => setData({...data, birth_date: t})} placeholder="YYYY-MM-DD oder YYYY" />
          </View>
        </View>
        <View style={styles.formRow}>
          <View style={styles.formField}>
            <Text style={styles.formLabel}>Kontakt</Text>
            <TextInput 
              style={styles.formInput} 
              value={data.phone || ''} 
              onChangeText={(t) => setData({...data, phone: t})} 
              placeholder="Telefonnummer..." 
              keyboardType="phone-pad"
            />
          </View>
          <View style={styles.formField}>
            <Text style={styles.formLabel}>IST-Stand</Text>
            <TextInput 
              style={styles.formInput} 
              value={data.current_status || ''} 
              onChangeText={(t) => setData({...data, current_status: t})} 
              placeholder="z.B. Termin am 15.01." 
            />
          </View>
        </View>
      </View>

      {/* Zweite S√§ule: Position + Einsch√§tzung */}
      <View style={[styles.detailInfo, { zIndex: 1 }]}>
        <View style={styles.detailRow}>
          <Text style={styles.detailLabel}>Position:</Text>
          <View style={styles.positionPickerSmall}>
            {POSITIONS.map(pos => {
              const currentPositions = parsePositions(data.position || '');
              const isSelected = currentPositions.includes(pos);
              return (
                <TouchableOpacity 
                  key={pos} 
                  style={[styles.positionOptionSmall, isSelected && styles.positionOptionSelected]} 
                  onPress={() => {
                    const newPositions = isSelected 
                      ? currentPositions.filter(p => p !== pos)
                      : [...currentPositions, pos];
                    setData({...data, position: formatPositions(newPositions)});
                  }}
                >
                  <Text style={[styles.positionOptionTextSmall, isSelected && styles.positionOptionTextSelected]}>{pos}</Text>
                </TouchableOpacity>
              );
            })}
          </View>
        </View>
        <View style={styles.detailRow}>
          <Text style={styles.detailLabel}>Einsch√§tzung:</Text>
          <View style={styles.ratingPickerSmall}>
            {[1,2,3,4,5,6,7,8,9,10].map(r => (
              <TouchableOpacity key={r} style={[styles.ratingOptionSmall, data.rating === r && styles.ratingOptionSelected]} onPress={() => setData({...data, rating: r})}>
                <Text style={[styles.ratingOptionTextSmall, data.rating === r && styles.ratingOptionTextSelected]}>{r}</Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>
      </View>

      {/* Dritte S√§ule: Transfermarkt + Scout */}
      <View style={styles.detailInfo}>
        <View style={styles.formField}>
          <Text style={styles.formLabel}>Transfermarkt Link</Text>
          <View style={styles.tmInputRow}>
            <TextInput 
              style={[styles.formInput, { flex: 1 }]} 
              value={data.transfermarkt_url || ''} 
              onChangeText={(t) => setData({...data, transfermarkt_url: t})} 
              placeholder="https://www.transfermarkt.de/spieler/profil/..." 
            />
            {data.transfermarkt_url && (
              <TouchableOpacity style={styles.tmButton} onPress={() => openTransfermarkt(data.transfermarkt_url)}>
                <Image source={TransfermarktLogo} style={styles.tmLogoMedium} />
              </TouchableOpacity>
            )}
          </View>
        </View>
      </View>

      {/* Vierte S√§ule: Weitere Infos */}
      <View style={[styles.detailSection, { marginBottom: 10 }]}>
        <Text style={styles.detailSectionTitle}>Weitere Infos</Text>
        <TextInput style={[styles.formInput, styles.textArea]} value={data.additional_info || ''} onChangeText={(t) => setData({...data, additional_info: t})} placeholder="Weitere Informationen..." multiline />
      </View>

      {/* Ganz unten: Fu√üballerische Einsch√§tzung */}
      <View style={[styles.detailSection, { marginBottom: 20 }]}>
        <Text style={styles.detailSectionTitle}>Fu√üballerische Einsch√§tzung</Text>
        <TextInput style={[styles.formInput, styles.textArea]} value={data.notes || ''} onChangeText={(t) => setData({...data, notes: t})} placeholder="Fu√üballerische Einsch√§tzung..." multiline />
      </View>
    </ScrollView>
  );

  const getPositionFilterLabel = () => {
    if (selectedPositions.length === 0) return 'Position';
    if (selectedPositions.length === 1) return selectedPositions[0];
    return `${selectedPositions.length} Positionen`;
  };

  const getYearFilterLabel = () => {
    if (selectedYears.length === 0) return 'Jahrgang';
    if (selectedYears.length === 1) return `Jg. ${selectedYears[0]}`;
    return `${selectedYears.length} Jahrg√§nge`;
  };

  const getRatingFilterLabel = () => {
    if (selectedRatings.length === 0) return 'Rating';
    if (selectedRatings.length === 1) return `${selectedRatings[0]}/10`;
    return `${selectedRatings.length} Ratings`;
  };

  // Alle Dropdowns schlie√üen
  const closeAllDropdowns = () => {
    setShowPositionDropdown(false);
    setShowYearDropdown(false);
    setShowRatingDropdown(false);
  };

  return (
    <Pressable style={styles.container} onPress={closeAllDropdowns}>
      <Sidebar activeScreen="scouting" navigation={navigation} />
      <View style={styles.mainContent}>
        {/* Header Banner - wei√ü mit Titel mittig */}
        <View style={styles.headerBanner}>
          <TouchableOpacity style={styles.filterButton} onPress={() => navigation.navigate('AdvisorDashboard')}>
            <Text style={styles.filterButtonText}>‚Üê Zur√ºck</Text>
          </TouchableOpacity>
          <View style={styles.headerBannerCenter}>
            <Text style={styles.title}>Scouting Area</Text>
            <Text style={styles.subtitle}>Manage Talente, Berichte und Spieltermine.</Text>
          </View>
          <View style={styles.headerTabs}>
            <TouchableOpacity style={[styles.filterButton, activeTab === 'spieler' && styles.filterButtonActive]} onPress={() => setActiveTab('spieler')}>
              <Text style={[styles.filterButtonText, activeTab === 'spieler' && styles.filterButtonTextActive]}>Spieler-Datenbank</Text>
            </TouchableOpacity>
            <TouchableOpacity style={[styles.filterButton, activeTab === 'spiele' && styles.filterButtonActive]} onPress={() => setActiveTab('spiele')}>
              <Text style={[styles.filterButtonText, activeTab === 'spiele' && styles.filterButtonTextActive]}>Scouting-Termine</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.toolbar}>
          <View style={styles.searchContainer}>
            <Text style={styles.searchIcon}>üîç</Text>
            <TextInput style={styles.searchInput} placeholder="Spieler, Verein suchen..." value={searchText} onChangeText={setSearchText} />
          </View>
          
          <View style={styles.filterContainer}>
            <View style={[styles.dropdownContainer, { zIndex: 30 }]}>
              <TouchableOpacity style={[styles.filterButton, selectedPositions.length > 0 && styles.filterButtonActive]} 
                onPress={(e) => { e.stopPropagation(); setShowPositionDropdown(!showPositionDropdown); setShowYearDropdown(false); setShowRatingDropdown(false); }}>
                <Text style={[styles.filterButtonText, selectedPositions.length > 0 && styles.filterButtonTextActive]}>{getPositionFilterLabel()} ‚ñº</Text>
              </TouchableOpacity>
              {showPositionDropdown && (
                <Pressable style={styles.filterDropdownMulti} onPress={(e) => e.stopPropagation()}>
                  <View style={styles.filterDropdownHeader}>
                    <Text style={styles.filterDropdownTitle}>Positionen w√§hlen</Text>
                    {selectedPositions.length > 0 && <TouchableOpacity onPress={clearPositions}><Text style={styles.filterClearText}>Alle l√∂schen</Text></TouchableOpacity>}
                  </View>
                  <ScrollView style={{ maxHeight: 250 }} nestedScrollEnabled>
                    {POSITIONS.map(pos => {
                      const isSelected = selectedPositions.includes(pos);
                      const count = scoutedPlayers.filter(p => p.position === pos).length;
                      return (
                        <TouchableOpacity key={pos} style={styles.filterCheckboxItem} onPress={() => togglePosition(pos)}>
                          <View style={[styles.checkbox, isSelected && styles.checkboxSelected]}>{isSelected && <Text style={styles.checkmark}>‚úì</Text>}</View>
                          <Text style={styles.filterCheckboxText}>{pos}</Text>
                          <Text style={styles.filterCountBadge}>{count}</Text>
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                  <TouchableOpacity style={styles.filterDoneButton} onPress={() => setShowPositionDropdown(false)}><Text style={styles.filterDoneText}>Fertig</Text></TouchableOpacity>
                </Pressable>
              )}
            </View>

            <View style={[styles.dropdownContainer, { zIndex: 20 }]}>
              <TouchableOpacity style={[styles.filterButton, selectedYears.length > 0 && styles.filterButtonActive]} 
                onPress={(e) => { e.stopPropagation(); setShowYearDropdown(!showYearDropdown); setShowPositionDropdown(false); setShowRatingDropdown(false); }}>
                <Text style={[styles.filterButtonText, selectedYears.length > 0 && styles.filterButtonTextActive]}>{getYearFilterLabel()} ‚ñº</Text>
              </TouchableOpacity>
              {showYearDropdown && (
                <Pressable style={styles.filterDropdownMulti} onPress={(e) => e.stopPropagation()}>
                  <View style={styles.filterDropdownHeader}>
                    <Text style={styles.filterDropdownTitle}>Jahrg√§nge w√§hlen</Text>
                    {selectedYears.length > 0 && <TouchableOpacity onPress={clearYears}><Text style={styles.filterClearText}>Alle l√∂schen</Text></TouchableOpacity>}
                  </View>
                  <ScrollView style={{ maxHeight: 250 }} nestedScrollEnabled>
                    {availableYears.length === 0 ? (
                      <Text style={styles.noDataText}>Keine Spieler vorhanden</Text>
                    ) : (
                      availableYears.map(year => {
                        const isSelected = selectedYears.includes(year);
                        const count = scoutedPlayers.filter(p => getYearFromDate(p.birth_date) === year).length;
                        return (
                          <TouchableOpacity key={year} style={styles.filterCheckboxItem} onPress={() => toggleYear(year)}>
                            <View style={[styles.checkbox, isSelected && styles.checkboxSelected]}>{isSelected && <Text style={styles.checkmark}>‚úì</Text>}</View>
                            <Text style={styles.filterCheckboxText}>Jg. {year}</Text>
                            <Text style={styles.filterCountBadge}>{count}</Text>
                          </TouchableOpacity>
                        );
                      })
                    )}
                  </ScrollView>
                  <TouchableOpacity style={styles.filterDoneButton} onPress={() => setShowYearDropdown(false)}><Text style={styles.filterDoneText}>Fertig</Text></TouchableOpacity>
                </Pressable>
              )}
            </View>

            {/* Rating Filter */}
            <View style={[styles.dropdownContainer, { zIndex: 10 }]}>
              <TouchableOpacity style={[styles.filterButton, selectedRatings.length > 0 && styles.filterButtonActive]} 
                onPress={(e) => { e.stopPropagation(); setShowRatingDropdown(!showRatingDropdown); setShowPositionDropdown(false); setShowYearDropdown(false); }}>
                <Text style={[styles.filterButtonText, selectedRatings.length > 0 && styles.filterButtonTextActive]}>{getRatingFilterLabel()} ‚ñº</Text>
              </TouchableOpacity>
              {showRatingDropdown && (
                <Pressable style={styles.filterDropdownMulti} onPress={(e) => e.stopPropagation()}>
                  <View style={styles.filterDropdownHeader}>
                    <Text style={styles.filterDropdownTitle}>Einsch√§tzung w√§hlen</Text>
                    {selectedRatings.length > 0 && <TouchableOpacity onPress={clearRatings}><Text style={styles.filterClearText}>Alle l√∂schen</Text></TouchableOpacity>}
                  </View>
                  <ScrollView style={{ maxHeight: 250 }} nestedScrollEnabled>
                    {[1,2,3,4,5,6,7,8,9,10].map(rating => {
                      const isSelected = selectedRatings.includes(rating);
                      const count = activePlayers.filter(p => p.rating === rating).length;
                      return (
                        <TouchableOpacity key={rating} style={styles.filterCheckboxItem} onPress={() => toggleRating(rating)}>
                          <View style={[styles.checkbox, isSelected && styles.checkboxSelected]}>{isSelected && <Text style={styles.checkmark}>‚úì</Text>}</View>
                          <Text style={styles.filterCheckboxText}>‚≠ê {rating}/10</Text>
                          <Text style={styles.filterCountBadge}>{count}</Text>
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                  <TouchableOpacity style={styles.filterDoneButton} onPress={() => setShowRatingDropdown(false)}><Text style={styles.filterDoneText}>Fertig</Text></TouchableOpacity>
                </Pressable>
              )}
            </View>
          </View>

          <View style={styles.viewToggle}>
            <TouchableOpacity style={[styles.viewButton, viewMode === 'kanban' && styles.viewButtonActive]} onPress={() => setViewMode('kanban')}>
              <Text style={[styles.viewButtonText, viewMode === 'kanban' && styles.viewButtonTextActive]}>Kanban</Text>
            </TouchableOpacity>
            <TouchableOpacity style={[styles.viewButton, viewMode === 'liste' && styles.viewButtonActive]} onPress={() => setViewMode('liste')}>
              <Text style={[styles.viewButtonText, viewMode === 'liste' && styles.viewButtonTextActive]}>Liste</Text>
            </TouchableOpacity>
            <TouchableOpacity style={[styles.viewButton, viewMode === 'archiv' && styles.viewButtonActive]} onPress={() => setViewMode('archiv')}>
              <Text style={[styles.viewButtonText, viewMode === 'archiv' && styles.viewButtonTextActive]}>Archiv ({archivedPlayersCount})</Text>
            </TouchableOpacity>
          </View>

          <TouchableOpacity style={styles.filterButton} onPress={() => activeTab === 'spieler' ? setShowAddPlayerModal(true) : setShowAddGameModal(true)}>
            <Text style={styles.filterButtonText}>{activeTab === 'spieler' ? 'neuen Spieler anlegen' : 'neues Spiel anlegen'}</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.content}>
          {activeTab === 'spieler' ? (
            viewMode === 'kanban' ? (
              <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.kanbanContainer}>
                {SCOUTING_STATUS.map(status => renderKanbanColumn(status))}
              </ScrollView>
            ) : viewMode === 'liste' ? (
              renderListView()
            ) : (
              renderArchivView()
            )
          ) : renderGamesTab()}
        </View>
      </View>

      {/* Add Player Modal */}
      <Modal visible={showAddPlayerModal} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, { overflow: 'visible' }]}>
            <View style={styles.detailHeader}>
              <Text style={styles.modalTitle}>Neuen Spieler hinzuf√ºgen</Text>
              <TouchableOpacity onPress={() => { setShowAddPlayerModal(false); setNewPlayerClubSearch(''); setShowNewPlayerClubDropdown(false); }} style={styles.closeButton}>
                <Text style={styles.closeButtonText}>‚úï</Text>
              </TouchableOpacity>
            </View>
            {renderPlayerForm(newPlayer, setNewPlayer, newPlayerClubSearch, setNewPlayerClubSearch, showNewPlayerClubDropdown, setShowNewPlayerClubDropdown)}
            <View style={styles.modalButtons}>
              <TouchableOpacity style={styles.cancelButton} onPress={() => { setShowAddPlayerModal(false); setNewPlayerClubSearch(''); setShowNewPlayerClubDropdown(false); }}>
                <Text style={styles.cancelButtonText}>Abbrechen</Text>
              </TouchableOpacity>
              <TouchableOpacity style={styles.saveButton} onPress={addScoutedPlayer}><Text style={styles.saveButtonText}>Hinzuf√ºgen</Text></TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Add Game Modal */}
      <Modal visible={showAddGameModal} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.detailHeader}>
              <Text style={styles.modalTitle}>Scouting-Spiel hinzuf√ºgen</Text>
              <TouchableOpacity onPress={() => setShowAddGameModal(false)} style={styles.closeButton}><Text style={styles.closeButtonText}>‚úï</Text></TouchableOpacity>
            </View>
            <View style={styles.formRow}>
              <View style={styles.formField}><Text style={styles.formLabel}>Datum</Text><TextInput style={styles.formInput} value={newGame.date} onChangeText={(t) => setNewGame({...newGame, date: t})} placeholder="YYYY-MM-DD" /></View>
              <View style={styles.formField}><Text style={styles.formLabel}>Ort</Text><TextInput style={styles.formInput} value={newGame.location} onChangeText={(t) => setNewGame({...newGame, location: t})} placeholder="Spielort" /></View>
            </View>
            <View style={styles.formRow}>
              <View style={styles.formField}><Text style={styles.formLabel}>Heimmannschaft</Text><TextInput style={styles.formInput} value={newGame.home_team} onChangeText={(t) => setNewGame({...newGame, home_team: t})} placeholder="Heim" /></View>
              <View style={styles.formField}><Text style={styles.formLabel}>Ausw√§rtsmannschaft</Text><TextInput style={styles.formInput} value={newGame.away_team} onChangeText={(t) => setNewGame({...newGame, away_team: t})} placeholder="Ausw√§rts" /></View>
            </View>
            <View style={styles.formField}><Text style={styles.formLabel}>Notizen</Text><TextInput style={[styles.formInput, styles.textArea]} value={newGame.notes} onChangeText={(t) => setNewGame({...newGame, notes: t})} placeholder="Notizen..." multiline /></View>
            <View style={styles.modalButtons}>
              <TouchableOpacity style={styles.cancelButton} onPress={() => setShowAddGameModal(false)}><Text style={styles.cancelButtonText}>Abbrechen</Text></TouchableOpacity>
              <TouchableOpacity style={styles.saveButton} onPress={addScoutingGame}><Text style={styles.saveButtonText}>Hinzuf√ºgen</Text></TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Player Detail Modal - New Layout */}
      {selectedPlayer && (
        <Modal visible={showPlayerDetailModal} transparent animationType="fade">
          <View style={styles.modalOverlay}>
            <View style={[styles.modalContentLarge, { overflow: 'visible' }]}>
              <View style={styles.detailHeader}>
                <View style={styles.detailHeaderLeft}>
                  <Text style={styles.detailName}>{selectedPlayer.first_name} {selectedPlayer.last_name}</Text>
                  <View style={styles.detailClubRow}>
                    <Text style={styles.detailClub}>{selectedPlayer.club || '-'}</Text>
                    {getClubLogo(selectedPlayer.club) && (
                      <Image source={{ uri: getClubLogo(selectedPlayer.club)! }} style={styles.detailClubLogo} />
                    )}
                  </View>
                </View>
                <TouchableOpacity onPress={() => { setShowPlayerDetailModal(false); setIsEditing(false); setShowEditClubDropdown(false); }} style={styles.closeButton}>
                  <Text style={styles.closeButtonText}>‚úï</Text>
                </TouchableOpacity>
              </View>

              {isEditing ? (
                renderPlayerForm(editData, setEditData, editClubSearchText, setEditClubSearchText, showEditClubDropdown, setShowEditClubDropdown)
              ) : (
                <ScrollView style={{ maxHeight: 500 }} showsVerticalScrollIndicator={false}>
                  {/* Two Column Layout */}
                  <View style={styles.detailTwoColumn}>
                    {/* Left Column: Grunddaten */}
                    <View style={styles.detailColumnLeft}>
                      <View style={styles.detailInfo}>
                        <View style={styles.detailRowVertical}>
                          <Text style={styles.detailLabelSmall}>Geburtsdatum</Text>
                          <Text style={styles.detailValueLarge}>{formatBirthDisplay(selectedPlayer.birth_date)}</Text>
                        </View>
                        <View style={styles.detailRowVertical}>
                          <Text style={styles.detailLabelSmall}>Position</Text>
                          <View style={styles.positionBadgesRowDetail}>
                            {parsePositions(selectedPlayer.position).map((pos, idx) => (
                              <View key={idx} style={styles.positionBadge}><Text style={styles.positionText}>{pos}</Text></View>
                            ))}
                          </View>
                        </View>
                        <View style={styles.detailRowVertical}>
                          <Text style={styles.detailLabelSmall}>Einsch√§tzung</Text>
                          <View style={styles.ratingBadgeLarge}><Text style={styles.ratingTextLarge}>‚≠ê {selectedPlayer.rating}/10</Text></View>
                        </View>
                        <View style={styles.detailRowVertical}>
                          <Text style={styles.detailLabelSmall}>Kontakt</Text>
                          <Text style={styles.detailValueLarge}>{selectedPlayer.phone || '-'}</Text>
                        </View>
                      </View>
                    </View>

                    {/* Right Column: Transfermarkt + Scout */}
                    <View style={styles.detailColumnRight}>
                      <View style={styles.detailInfo}>
                        <View style={styles.detailRowVertical}>
                          <Text style={styles.detailLabelSmall}>Transfermarkt</Text>
                          {selectedPlayer.transfermarkt_url ? (
                            <TouchableOpacity onPress={() => openTransfermarkt(selectedPlayer.transfermarkt_url!)} style={styles.tmLinkRowDetail}>
                              <Image source={TransfermarktLogo} style={styles.tmLogoDetail} />
                            </TouchableOpacity>
                          ) : (
                            <Text style={styles.detailValueLarge}>-</Text>
                          )}
                        </View>
                        <View style={styles.detailRowVertical}>
                          <Text style={styles.detailLabelSmall}>Scout</Text>
                          <Text style={styles.detailValueLarge}>{selectedPlayer.scout_name || '-'}</Text>
                        </View>
                      </View>
                      {/* Weitere Infos */}
                      <View style={styles.detailInfoScout}>
                        <View style={styles.detailRowVertical}>
                          <Text style={styles.detailLabelSmall}>Weitere Infos</Text>
                          <Text style={styles.detailValueLarge}>{selectedPlayer.additional_info || '-'}</Text>
                        </View>
                        <View style={[styles.detailRowVertical, { marginBottom: 0 }]}>
                          <Text style={styles.detailLabelSmall}>IST-Stand</Text>
                          <Text style={styles.detailValueLarge}>{selectedPlayer.current_status || '-'}</Text>
                        </View>
                      </View>
                    </View>
                  </View>

                  {/* Fu√üballerische Einsch√§tzung in eigener S√§ule */}
                  <View style={[styles.detailInfo, { marginTop: 16 }]}>
                    <View style={[styles.detailRowVertical, { marginBottom: 0 }]}>
                      <Text style={styles.detailLabelSmall}>Fu√üballerische Einsch√§tzung</Text>
                      <Text style={styles.detailValueLarge}>{selectedPlayer.notes || '-'}</Text>
                    </View>
                  </View>
                </ScrollView>
              )}

              <View style={styles.modalButtons}>
                {isEditing ? (
                  <>
                    <TouchableOpacity style={styles.deleteButton} onPress={() => deleteScoutedPlayer(selectedPlayer.id)}><Text style={styles.deleteButtonText}>L√∂schen</Text></TouchableOpacity>
                    <TouchableOpacity style={styles.cancelButton} onPress={() => { setIsEditing(false); setShowEditClubDropdown(false); }}><Text style={styles.cancelButtonText}>Abbrechen</Text></TouchableOpacity>
                    <TouchableOpacity style={styles.saveButton} onPress={updateScoutedPlayer}><Text style={styles.saveButtonText}>Speichern</Text></TouchableOpacity>
                  </>
                ) : (
                  <>
                    <TouchableOpacity style={styles.decisionButton} onPress={() => { setShowPlayerDetailModal(false); setShowDecisionModal(true); }}><Text style={styles.decisionButtonText}>Entscheidung</Text></TouchableOpacity>
                    <TouchableOpacity style={styles.editButton} onPress={() => setIsEditing(true)}><Text style={styles.editButtonText}>Bearbeiten</Text></TouchableOpacity>
                  </>
                )}
              </View>
            </View>
          </View>
        </Modal>
      )}

      {/* Entscheidungs-Modal */}
      <Modal visible={showDecisionModal} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.decisionModalContent}>
            <Text style={styles.decisionModalTitle}>Entscheidung treffen</Text>
            <Text style={styles.decisionModalSubtitle}>{selectedPlayer?.first_name} {selectedPlayer?.last_name}</Text>
            
            <View style={styles.decisionButtonsContainer}>
              <TouchableOpacity style={styles.transferButton} onPress={() => { setShowDecisionModal(false); setShowTransferModal(true); }}>
                <Text style={styles.transferButtonIcon}>‚úì</Text>
                <Text style={styles.transferButtonText}>√úbernehmen</Text>
                <Text style={styles.transferButtonSubtext}>In Spieler√ºbersicht</Text>
              </TouchableOpacity>
              
              <TouchableOpacity style={styles.archiveButton} onPress={() => { setShowDecisionModal(false); setShowArchiveModal(true); }}>
                <Text style={styles.archiveButtonIcon}>‚úó</Text>
                <Text style={styles.archiveButtonText}>Archivieren</Text>
                <Text style={styles.archiveButtonSubtext}>Ins Archiv verschieben</Text>
              </TouchableOpacity>
            </View>
            
            <TouchableOpacity style={styles.decisionCancelButton} onPress={() => setShowDecisionModal(false)}>
              <Text style={styles.decisionCancelButtonText}>Abbrechen</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Archiv-Modal */}
      <Modal visible={showArchiveModal} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Spieler archivieren</Text>
            <Text style={styles.modalSubtitle}>{selectedPlayer?.first_name} {selectedPlayer?.last_name}</Text>
            
            <View style={styles.formField}>
              <Text style={styles.formLabel}>Grund f√ºr Archivierung</Text>
              <TextInput 
                style={[styles.formInput, styles.textArea]} 
                value={archiveReason} 
                onChangeText={setArchiveReason} 
                placeholder="z.B. Kein Interesse, Spieler hat abgesagt, andere Agentur gew√§hlt..." 
                multiline
              />
            </View>
            
            <View style={styles.modalButtons}>
              <TouchableOpacity style={styles.cancelButton} onPress={() => { setShowArchiveModal(false); setArchiveReason(''); }}>
                <Text style={styles.cancelButtonText}>Abbrechen</Text>
              </TouchableOpacity>
              <TouchableOpacity style={styles.archiveConfirmButton} onPress={archivePlayer}>
                <Text style={styles.archiveConfirmButtonText}>Archivieren</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Transfer/√úbernahme-Modal */}
      <Modal visible={showTransferModal} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Spieler √ºbernehmen</Text>
            <Text style={styles.modalSubtitle}>{selectedPlayer?.first_name} {selectedPlayer?.last_name} in die Spieler√ºbersicht √ºbernehmen</Text>
            
            <View style={styles.formField}>
              <Text style={styles.formLabel}>Listung *</Text>
              <View style={styles.listingSelector}>
                {LISTINGS.map(listing => (
                  <TouchableOpacity 
                    key={listing} 
                    style={[styles.listingOption, transferListing === listing && styles.listingOptionSelected]}
                    onPress={() => setTransferListing(listing)}
                  >
                    <Text style={[styles.listingOptionText, transferListing === listing && styles.listingOptionTextSelected]}>{listing}</Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
            
            <View style={styles.formField}>
              <Text style={styles.formLabel}>Zust√§ndiger Berater *</Text>
              <View style={styles.advisorSelector}>
                {advisors.map(advisor => (
                  <TouchableOpacity 
                    key={advisor.id} 
                    style={[styles.advisorOption, transferResponsibility === `${advisor.first_name} ${advisor.last_name}` && styles.advisorOptionSelected]}
                    onPress={() => setTransferResponsibility(`${advisor.first_name} ${advisor.last_name}`)}
                  >
                    <Text style={[styles.advisorOptionText, transferResponsibility === `${advisor.first_name} ${advisor.last_name}` && styles.advisorOptionTextSelected]}>
                      {advisor.first_name} {advisor.last_name}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
            
            <View style={styles.modalButtons}>
              <TouchableOpacity style={styles.cancelButton} onPress={() => { setShowTransferModal(false); setTransferListing(''); setTransferResponsibility(''); }}>
                <Text style={styles.cancelButtonText}>Abbrechen</Text>
              </TouchableOpacity>
              <TouchableOpacity style={styles.transferConfirmButton} onPress={transferToPlayers}>
                <Text style={styles.transferConfirmButtonText}>√úbernehmen</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, flexDirection: 'row', backgroundColor: '#f8fafc' },
  mainContent: { flex: 1 },
  
  // Header Banner - wei√ü mit Titel mittig
  headerBanner: { flexDirection: 'row', alignItems: 'center', padding: 24, backgroundColor: '#fff', borderBottomWidth: 1, borderBottomColor: '#e2e8f0' },
  headerBannerCenter: { flex: 1, alignItems: 'center' },
  title: { fontSize: 28, fontWeight: '700', color: '#1a1a1a' },
  subtitle: { fontSize: 14, color: '#64748b', marginTop: 4 },
  headerTabs: { flexDirection: 'row', gap: 8 },
  headerTab: { flexDirection: 'row', alignItems: 'center', paddingVertical: 10, paddingHorizontal: 16, borderRadius: 8, backgroundColor: '#fff', borderWidth: 1, borderColor: '#e2e8f0' },
  headerTabActive: { backgroundColor: '#1a1a1a', borderColor: '#1a1a1a' },
  headerTabIcon: { fontSize: 16, marginRight: 8 },
  headerTabText: { fontSize: 14, color: '#64748b', fontWeight: '500' },
  headerTabTextActive: { color: '#fff' },
  
  // Toolbar - wei√ü umrandet
  toolbar: { flexDirection: 'row', alignItems: 'center', gap: 12, padding: 16, backgroundColor: '#fff', borderBottomWidth: 1, borderBottomColor: '#e2e8f0', zIndex: 100 },
  searchContainer: { flex: 1, flexDirection: 'row', alignItems: 'center', backgroundColor: '#f8fafc', borderRadius: 8, borderWidth: 1, borderColor: '#e2e8f0', paddingHorizontal: 12 },
  searchIcon: { fontSize: 16, marginRight: 8 },
  searchInput: { flex: 1, paddingVertical: 10, fontSize: 14 },
  filterContainer: { flexDirection: 'row', gap: 8 },
  dropdownContainer: { position: 'relative' },
  filterButton: { paddingVertical: 10, paddingHorizontal: 16, borderRadius: 8, backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#e2e8f0' },
  filterButtonActive: { backgroundColor: '#e0f2fe', borderColor: '#3b82f6' },
  filterButtonText: { fontSize: 14, color: '#64748b' },
  filterButtonTextActive: { color: '#0369a1' },
  filterDropdownMulti: { position: 'absolute', top: '100%', left: 0, backgroundColor: '#fff', borderRadius: 12, borderWidth: 1, borderColor: '#e2e8f0', marginTop: 4, minWidth: 220, shadowColor: '#000', shadowOpacity: 0.15, shadowRadius: 12, zIndex: 1000, overflow: 'hidden' },
  filterDropdownHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', padding: 12, borderBottomWidth: 1, borderBottomColor: '#e2e8f0', backgroundColor: '#f8fafc' },
  filterDropdownTitle: { fontSize: 13, fontWeight: '600', color: '#1a1a1a' },
  filterClearText: { fontSize: 12, color: '#ef4444' },
  filterCheckboxItem: { flexDirection: 'row', alignItems: 'center', paddingVertical: 10, paddingHorizontal: 12, borderBottomWidth: 1, borderBottomColor: '#f1f5f9' },
  checkbox: { width: 20, height: 20, borderRadius: 4, borderWidth: 2, borderColor: '#cbd5e1', marginRight: 10, justifyContent: 'center', alignItems: 'center' },
  checkboxSelected: { backgroundColor: '#3b82f6', borderColor: '#3b82f6' },
  checkmark: { color: '#fff', fontSize: 12, fontWeight: 'bold' },
  filterCheckboxText: { flex: 1, fontSize: 14, color: '#333' },
  filterCountBadge: { backgroundColor: '#f1f5f9', paddingHorizontal: 8, paddingVertical: 2, borderRadius: 10, fontSize: 12, color: '#64748b' },
  filterDoneButton: { padding: 12, backgroundColor: '#f8fafc', alignItems: 'center', borderTopWidth: 1, borderTopColor: '#e2e8f0' },
  filterDoneText: { fontSize: 14, fontWeight: '600', color: '#3b82f6' },
  noDataText: { padding: 16, textAlign: 'center', color: '#94a3b8', fontSize: 14 },
  viewToggle: { flexDirection: 'row', backgroundColor: '#f8fafc', borderRadius: 8, padding: 4 },
  viewButton: { paddingVertical: 8, paddingHorizontal: 12, borderRadius: 6 },
  viewButtonActive: { backgroundColor: '#fff', shadowColor: '#000', shadowOpacity: 0.1, shadowRadius: 4 },
  viewButtonText: { fontSize: 14, color: '#64748b' },
  addButton: { paddingVertical: 10, paddingHorizontal: 20, borderRadius: 8, backgroundColor: '#1a1a1a' },
  addButtonText: { fontSize: 14, color: '#fff', fontWeight: '600' },
  content: { flex: 1, padding: 16 },
  kanbanContainer: { flex: 1 },
  kanbanColumn: { width: 300, backgroundColor: '#f1f5f9', borderRadius: 12, marginRight: 16, padding: 12, minHeight: 400 },
  kanbanColumnDropTarget: { backgroundColor: '#dbeafe', borderWidth: 2, borderColor: '#3b82f6', borderStyle: 'dashed' },
  kanbanHeader: { flexDirection: 'row', alignItems: 'center', marginBottom: 12, paddingBottom: 12, borderBottomWidth: 1, borderBottomColor: '#e2e8f0' },
  statusDot: { width: 10, height: 10, borderRadius: 5, marginRight: 8 },
  kanbanTitle: { fontSize: 14, fontWeight: '600', color: '#475569', flex: 1 },
  countBadge: { backgroundColor: '#e2e8f0', paddingHorizontal: 8, paddingVertical: 2, borderRadius: 10 },
  countText: { fontSize: 12, color: '#64748b', fontWeight: '600' },
  kanbanContent: { flex: 1 },
  playerCard: { backgroundColor: '#fff', borderRadius: 10, marginBottom: 10, shadowColor: '#000', shadowOpacity: 0.05, shadowRadius: 4, shadowOffset: { width: 0, height: 2 } },
  cardContent: { padding: 12 },
  cardHeader: { flexDirection: 'row', alignItems: 'center' },
  clubLogoCard: { width: 32, height: 32, resizeMode: 'contain', marginRight: 10 },
  cardInfo: { flex: 1 },
  playerName: { fontSize: 16, fontWeight: '600', color: '#1a1a1a' },
  playerYear: { fontSize: 14, color: '#64748b', marginTop: 2 },
  playerClub: { fontSize: 12, color: '#64748b', marginTop: 2 },
  cardRight: { alignItems: 'flex-end', gap: 4 },
  positionBadgesRow: { flexDirection: 'row', gap: 4, flexWrap: 'wrap', justifyContent: 'flex-end' },
  ratingBadgeCard: { backgroundColor: '#dcfce7', paddingVertical: 2, paddingHorizontal: 6, borderRadius: 4 },
  ratingTextCard: { fontSize: 10, fontWeight: '600', color: '#166534' },
  birthYear: { fontSize: 11, color: '#64748b' },
  clubLogoSmall: { width: 28, height: 28, resizeMode: 'contain', marginTop: 4 },
  cardFooter: { flexDirection: 'row', alignItems: 'center', marginTop: 10, paddingTop: 10, borderTopWidth: 1, borderTopColor: '#f1f5f9' },
  positionBadge: { backgroundColor: '#e0f2fe', paddingVertical: 4, paddingHorizontal: 8, borderRadius: 4 },
  positionText: { fontSize: 11, fontWeight: '600', color: '#0369a1' },
  ratingBadge: { backgroundColor: '#dcfce7', paddingVertical: 4, paddingHorizontal: 8, borderRadius: 4 },
  ratingText: { fontSize: 11, fontWeight: '600', color: '#166534' },
  ratingBadgeSmall: { backgroundColor: '#dcfce7', paddingVertical: 2, paddingHorizontal: 6, borderRadius: 4 },
  ratingTextSmall: { fontSize: 11, fontWeight: '600', color: '#166534' },
  ratingBadgeList: { backgroundColor: '#dcfce7', paddingVertical: 2, paddingHorizontal: 6, borderRadius: 4, alignSelf: 'flex-start' },
  ratingTextList: { fontSize: 12, fontWeight: '500', color: '#166534' },
  tmIconSmall: { padding: 2 },
  tmLogoSmall: { width: 24, height: 16, resizeMode: 'contain' },
  tmLogoMedium: { width: 32, height: 20, resizeMode: 'contain' },
  tmLogoLarge: { width: 40, height: 26, resizeMode: 'contain' },
  tmLogoInline: { width: 28, height: 18, resizeMode: 'contain' },
  tmButton: { backgroundColor: '#fff', paddingVertical: 8, paddingHorizontal: 8, borderRadius: 8, marginLeft: 8, borderWidth: 1, borderColor: '#e2e8f0' },
  tmButtonLarge: { backgroundColor: '#fff', paddingVertical: 6, paddingHorizontal: 10, borderRadius: 8, marginRight: 12, borderWidth: 1, borderColor: '#e2e8f0' },
  tmLinkRow: { flexDirection: 'row', alignItems: 'center', gap: 8 },
  tmLinkText: { fontSize: 14, color: '#0369a1', fontWeight: '500' },
  tmInputRow: { flexDirection: 'row', alignItems: 'center' },
  tableContainer: { flex: 1, backgroundColor: '#fff', borderRadius: 12, overflow: 'hidden' },
  tableHeader: { flexDirection: 'row', backgroundColor: '#f8fafc', paddingVertical: 12, paddingHorizontal: 16, borderBottomWidth: 1, borderBottomColor: '#e2e8f0' },
  tableHeaderCell: { fontSize: 12, fontWeight: '600', color: '#64748b', textTransform: 'uppercase' },
  tableRow: { flexDirection: 'row', paddingVertical: 12, paddingHorizontal: 16, borderBottomWidth: 1, borderBottomColor: '#f1f5f9', alignItems: 'center' },
  tableCell: { fontSize: 14, color: '#1a1a1a' },
  tableCellText: { fontSize: 14, color: '#1a1a1a', fontWeight: '500' },
  ratingTextList: { color: '#166534', fontWeight: '600' },
  clubLogoTable: { width: 24, height: 24, resizeMode: 'contain' },
  positionBadgeSmall: { backgroundColor: '#e0f2fe', paddingVertical: 2, paddingHorizontal: 6, borderRadius: 4, alignSelf: 'flex-start' },
  positionTextSmall: { fontSize: 11, fontWeight: '600', color: '#0369a1' },
  statusBadge: { paddingVertical: 4, paddingHorizontal: 8, borderRadius: 4 },
  statusBadgeText: { fontSize: 11, fontWeight: '600' },
  gamesContainer: { flex: 1, backgroundColor: '#fff', borderRadius: 12, overflow: 'hidden' },
  clubSelectorContainer: { position: 'relative', zIndex: 9999 },
  clubDropdown: { position: 'absolute', top: '100%', left: 0, right: 0, backgroundColor: '#fff', borderRadius: 8, borderWidth: 1, borderColor: '#e2e8f0', marginTop: 4, shadowColor: '#000', shadowOpacity: 0.15, shadowRadius: 10, zIndex: 9999, elevation: 9999 },
  clubDropdownScroll: { maxHeight: 200 },
  clubDropdownItem: { flexDirection: 'row', alignItems: 'center', paddingVertical: 10, paddingHorizontal: 12, borderBottomWidth: 1, borderBottomColor: '#f1f5f9', backgroundColor: '#fff' },
  clubDropdownLogo: { width: 24, height: 24, resizeMode: 'contain', marginRight: 10 },
  clubDropdownText: { fontSize: 14, color: '#333' },
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', alignItems: 'center' },
  modalContent: { backgroundColor: '#fff', borderRadius: 16, padding: 24, width: '90%', maxWidth: 600, maxHeight: '90%', zIndex: 1 },
  modalContentLarge: { backgroundColor: '#fff', borderRadius: 16, padding: 24, width: '90%', maxWidth: 800, maxHeight: '90%', zIndex: 1 },
  modalTitle: { fontSize: 20, fontWeight: '700', color: '#1a1a1a' },
  detailHeaderLeft: { flex: 1 },
  detailClubRow: { flexDirection: 'row', alignItems: 'center', marginTop: 4, gap: 8 },
  detailClubLogo: { width: 24, height: 24, resizeMode: 'contain' },
  detailTwoColumn: { flexDirection: 'row', gap: 20 },
  detailColumnLeft: { flex: 1 },
  detailColumnRight: { flex: 1 },
  detailRowVertical: { marginBottom: 16 },
  detailLabelSmall: { fontSize: 12, color: '#64748b', marginBottom: 4 },
  detailValueLarge: { fontSize: 15, color: '#1a1a1a', fontWeight: '500' },
  positionBadgesRowDetail: { flexDirection: 'row', flexWrap: 'wrap', gap: 6 },
  ratingBadgeLarge: { backgroundColor: '#dcfce7', paddingVertical: 6, paddingHorizontal: 10, borderRadius: 6, alignSelf: 'flex-start' },
  ratingTextLarge: { fontSize: 14, fontWeight: '600', color: '#166534' },
  tmLinkRowDetail: { flexDirection: 'row', alignItems: 'center' },
  tmLogoDetail: { width: 80, height: 24, resizeMode: 'contain' },
  detailInfoScout: { backgroundColor: '#f8fafc', borderRadius: 8, padding: 12, marginTop: 12 },
  formRow: { flexDirection: 'row', gap: 16, marginBottom: 16 },
  formField: { flex: 1, marginBottom: 8 },
  formLabel: { fontSize: 13, color: '#64748b', marginBottom: 6, fontWeight: '500' },
  formInput: { borderWidth: 1, borderColor: '#e2e8f0', borderRadius: 8, padding: 12, fontSize: 14, backgroundColor: '#fff' },
  inputDisabled: { backgroundColor: '#f8fafc', color: '#64748b' },
  textArea: { minHeight: 80, textAlignVertical: 'top' },
  positionPickerSmall: { flexDirection: 'row', flexWrap: 'wrap', gap: 4, flex: 1 },
  positionOptionSmall: { paddingVertical: 4, paddingHorizontal: 8, borderRadius: 4, backgroundColor: '#f1f5f9' },
  positionOptionSelected: { backgroundColor: '#1a1a1a' },
  positionOptionTextSmall: { fontSize: 11, color: '#64748b', fontWeight: '500' },
  positionOptionTextSelected: { color: '#fff' },
  ratingPickerSmall: { flexDirection: 'row', gap: 4, flex: 1 },
  ratingOptionSmall: { width: 26, height: 26, borderRadius: 4, backgroundColor: '#f1f5f9', justifyContent: 'center', alignItems: 'center' },
  ratingOptionSelected: { backgroundColor: '#1a1a1a' },
  ratingOptionTextSmall: { fontSize: 11, color: '#64748b', fontWeight: '600' },
  ratingOptionTextSelected: { color: '#fff' },
  modalButtons: { flexDirection: 'row', justifyContent: 'flex-end', gap: 12, marginTop: 24, paddingTop: 16, borderTopWidth: 1, borderTopColor: '#e2e8f0' },
  cancelButton: { paddingVertical: 10, paddingHorizontal: 16, borderRadius: 8, backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#e2e8f0' },
  cancelButtonText: { fontSize: 14, color: '#64748b' },
  saveButton: { paddingVertical: 10, paddingHorizontal: 16, borderRadius: 8, backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#10b981' },
  saveButtonText: { fontSize: 14, color: '#10b981', fontWeight: '500' },
  editButton: { paddingVertical: 10, paddingHorizontal: 16, borderRadius: 8, backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#3b82f6' },
  editButtonText: { fontSize: 14, color: '#3b82f6', fontWeight: '500' },
  deleteButton: { paddingVertical: 10, paddingHorizontal: 16, borderRadius: 8, backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#ef4444', marginRight: 'auto' },
  deleteButtonText: { fontSize: 14, color: '#ef4444', fontWeight: '500' },
  decisionButton: { paddingVertical: 10, paddingHorizontal: 16, borderRadius: 8, backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#f59e0b', marginRight: 'auto' },
  decisionButtonText: { fontSize: 14, color: '#f59e0b', fontWeight: '500' },
  closeButton: { width: 32, height: 32, borderRadius: 16, backgroundColor: '#f1f5f9', justifyContent: 'center', alignItems: 'center' },
  closeButtonText: { fontSize: 16, color: '#64748b' },
  detailHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: 20, zIndex: 1000 },
  detailName: { fontSize: 22, fontWeight: '700', color: '#1a1a1a' },
  detailClub: { fontSize: 14, color: '#64748b', marginTop: 4 },
  detailInfo: { backgroundColor: '#f8fafc', borderRadius: 12, padding: 16, marginBottom: 16 },
  detailRow: { flexDirection: 'row', alignItems: 'center', marginBottom: 12 },
  detailLabel: { fontSize: 13, color: '#64748b', width: 100 },
  detailValue: { fontSize: 14, color: '#1a1a1a', fontWeight: '500', flex: 1 },
  detailSection: { marginBottom: 16 },
  detailSectionTitle: { fontSize: 14, fontWeight: '600', color: '#1a1a1a', marginBottom: 12 },
  notesText: { fontSize: 14, color: '#475569', lineHeight: 20, backgroundColor: '#f8fafc', padding: 12, borderRadius: 8 },
  editInput: { borderWidth: 1, borderColor: '#e2e8f0', borderRadius: 6, padding: 8, fontSize: 14, backgroundColor: '#fff' },
  // IST-Stand auf Kanban-Karte
  currentStatusRow: { marginTop: 10, paddingTop: 10, borderTopWidth: 1, borderTopColor: '#f1f5f9' },
  currentStatusText: { fontSize: 12, color: '#64748b', fontStyle: 'italic' },
  // Archiv
  emptyArchiv: { padding: 40, alignItems: 'center' },
  emptyArchivText: { fontSize: 14, color: '#94a3b8' },
  restoreButton: { backgroundColor: '#10b981', paddingVertical: 6, paddingHorizontal: 12, borderRadius: 6 },
  restoreButtonText: { fontSize: 12, color: '#fff', fontWeight: '600' },
  // Entscheidungs-Modal
  decisionModalContent: { backgroundColor: '#fff', borderRadius: 16, padding: 32, width: '90%', maxWidth: 450, alignItems: 'center' },
  decisionModalTitle: { fontSize: 22, fontWeight: '700', color: '#1a1a1a', marginBottom: 8 },
  decisionModalSubtitle: { fontSize: 16, color: '#64748b', marginBottom: 24 },
  decisionButtonsContainer: { flexDirection: 'row', gap: 16, marginBottom: 24 },
  transferButton: { backgroundColor: '#dcfce7', padding: 24, borderRadius: 12, alignItems: 'center', flex: 1, borderWidth: 2, borderColor: '#10b981' },
  transferButtonIcon: { fontSize: 32, color: '#10b981', marginBottom: 8 },
  transferButtonText: { fontSize: 16, fontWeight: '600', color: '#166534' },
  transferButtonSubtext: { fontSize: 12, color: '#166534', marginTop: 4 },
  archiveButton: { backgroundColor: '#fef2f2', padding: 24, borderRadius: 12, alignItems: 'center', flex: 1, borderWidth: 2, borderColor: '#ef4444' },
  archiveButtonIcon: { fontSize: 32, color: '#ef4444', marginBottom: 8 },
  archiveButtonText: { fontSize: 16, fontWeight: '600', color: '#991b1b' },
  archiveButtonSubtext: { fontSize: 12, color: '#991b1b', marginTop: 4 },
  decisionCancelButton: { paddingVertical: 12, paddingHorizontal: 24 },
  decisionCancelButtonText: { fontSize: 14, color: '#64748b' },
  modalSubtitle: { fontSize: 14, color: '#64748b', marginBottom: 20 },
  archiveConfirmButton: { paddingVertical: 12, paddingHorizontal: 20, borderRadius: 8, backgroundColor: '#ef4444' },
  archiveConfirmButtonText: { fontSize: 14, color: '#fff', fontWeight: '600' },
  transferConfirmButton: { paddingVertical: 12, paddingHorizontal: 20, borderRadius: 8, backgroundColor: '#10b981' },
  transferConfirmButtonText: { fontSize: 14, color: '#fff', fontWeight: '600' },
  listingSelector: { flexDirection: 'row', gap: 8, flexWrap: 'wrap' },
  listingOption: { paddingVertical: 10, paddingHorizontal: 16, borderRadius: 8, backgroundColor: '#f1f5f9', borderWidth: 1, borderColor: '#e2e8f0' },
  listingOptionSelected: { backgroundColor: '#1a1a1a', borderColor: '#1a1a1a' },
  listingOptionText: { fontSize: 13, color: '#64748b' },
  listingOptionTextSelected: { color: '#fff' },
  advisorSelector: { flexDirection: 'row', gap: 8, flexWrap: 'wrap' },
  advisorOption: { paddingVertical: 8, paddingHorizontal: 14, borderRadius: 8, backgroundColor: '#f1f5f9', borderWidth: 1, borderColor: '#e2e8f0' },
  advisorOptionSelected: { backgroundColor: '#3b82f6', borderColor: '#3b82f6' },
  advisorOptionText: { fontSize: 13, color: '#64748b' },
  advisorOptionTextSelected: { color: '#fff' },
  viewButtonTextActive: { color: '#1a1a1a', fontWeight: '600' },
});
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, TextInput, Alert, Image, Linking, Modal } from 'react-native';
import { supabase } from '../../config/supabase';
import * as DocumentPicker from 'expo-document-picker';

const POSITIONS = ['Torwart', 'Innenverteidiger', 'Linker Verteidiger', 'Rechter Verteidiger', 'Defensives Mittelfeld', 'Offensives Mittelfeld', 'Linke Au√üenbahn', 'Rechte Au√üenbahn', 'St√ºrmer'];
const LISTINGS = ['Karl Herzog Sportmanagement', 'PM Sportmanagement'];
const COUNTRIES = ['Afghanistan', '√Ñgypten', 'Albanien', 'Algerien', 'Andorra', 'Angola', 'Argentinien', 'Armenien', 'Aserbaidschan', '√Ñthiopien', 'Australien', 'Belgien', 'Bosnien und Herzegowina', 'Brasilien', 'Bulgarien', 'Chile', 'China', 'Costa Rica', 'D√§nemark', 'Deutschland', 'Dominikanische Republik', 'Ecuador', 'El Salvador', 'England', 'Estland', 'Finnland', 'Frankreich', 'Georgien', 'Ghana', 'Griechenland', 'Guatemala', 'Haiti', 'Honduras', 'Hongkong', 'Indien', 'Indonesien', 'Irak', 'Iran', 'Irland', 'Island', 'Israel', 'Italien', 'Jamaika', 'Japan', 'Jordanien', 'Kamerun', 'Kanada', 'Kasachstan', 'Katar', 'Kenia', 'Kolumbien', 'Kosovo', 'Kroatien', 'Kuba', 'Lettland', 'Libanon', 'Libyen', 'Liechtenstein', 'Litauen', 'Luxemburg', 'Marokko', 'Mexiko', 'Moldau', 'Monaco', 'Montenegro', 'Namibia', 'Neuseeland', 'Niederlande', 'Nigeria', 'Nordmazedonien', 'Norwegen', '√ñsterreich', 'Pakistan', 'Pal√§stina', 'Panama', 'Paraguay', 'Peru', 'Philippinen', 'Polen', 'Portugal', 'Rum√§nien', 'Russland', 'Saudi-Arabien', 'Schottland', 'Schweden', 'Schweiz', 'Senegal', 'Serbien', 'Singapur', 'Slowakei', 'Slowenien', 'Spanien', 'S√ºdafrika', 'S√ºdkorea', 'Syrien', 'Taiwan', 'Thailand', 'Tschechien', 'Tunesien', 'T√ºrkei', 'Uganda', 'Ukraine', 'Ungarn', 'Uruguay', 'USA', 'Usbekistan', 'Venezuela', 'Vereinigte Arabische Emirate', 'Vietnam', 'Wales', 'Wei√ürussland', 'Zypern'];
const HEIGHTS = Array.from({ length: 101 }, (_, i) => 120 + i);
const COUNTRY_CODES = [
  { code: '+49', country: 'Deutschland' }, { code: '+43', country: '√ñsterreich' }, { code: '+41', country: 'Schweiz' },
  { code: '+33', country: 'Frankreich' }, { code: '+31', country: 'Niederlande' }, { code: '+32', country: 'Belgien' },
  { code: '+39', country: 'Italien' }, { code: '+34', country: 'Spanien' }, { code: '+44', country: 'England' },
  { code: '+48', country: 'Polen' }, { code: '+420', country: 'Tschechien' }, { code: '+45', country: 'D√§nemark' },
  { code: '+46', country: 'Schweden' }, { code: '+47', country: 'Norwegen' }, { code: '+90', country: 'T√ºrkei' },
  { code: '+385', country: 'Kroatien' }, { code: '+381', country: 'Serbien' }, { code: '+30', country: 'Griechenland' },
  { code: '+351', country: 'Portugal' }, { code: '+1', country: 'USA/Kanada' },
];

const InstagramIcon = require('../../../assets/instagram.png.webp');
const LinkedInIcon = require('../../../assets/linkedin.png');
const TikTokIcon = require('../../../assets/tiktok.png');
const TransfermarktIcon = require('../../../assets/transfermarkt-logo.png');
const ArbeitsamtIcon = require('../../../assets/arbeitsamt.png');

interface Player {
  id: string; first_name: string; last_name: string; nationality: string; birth_date: string; club: string; league: string; position: string; contract_end: string; photo_url: string; strong_foot: string; height: number; secondary_position: string; salary_month: string; point_bonus: string; appearance_bonus: string; contract_option: string; contract_scope: string; fixed_fee: string; contract_notes: string; u23_player: boolean; provision: string; transfer_commission: string; mandate_until: string; responsibility: string; listing: string; phone: string; phone_country_code: string; email: string; education: string; training: string; instagram: string; linkedin: string; tiktok: string; transfermarkt_url: string; interests: string; father_name: string; father_phone: string; father_phone_country_code: string; father_job: string; mother_name: string; mother_phone: string; mother_phone_country_code: string; mother_job: string; siblings: string; other_notes: string; injuries: string; street: string; postal_code: string; city: string; internat: boolean; future_club: string; future_contract_end: string; contract_documents: any[]; provision_documents: any[]; transfer_commission_documents: any[]; fussball_de_url: string;
}

interface ClubLogo {
  club_name: string;
  logo_url: string;
}

interface Advisor {
  id: string;
  first_name: string;
  last_name: string;
}

export function PlayerDetailScreen({ route, navigation }: any) {
  const { playerId } = route.params;
  const [player, setPlayer] = useState<Player | null>(null);
  const [loading, setLoading] = useState(true);
  const [editing, setEditing] = useState(false);
  const [editData, setEditData] = useState<Player | null>(null);
  const [selectedPositions, setSelectedPositions] = useState<string[]>([]);
  const [selectedSecondaryPositions, setSelectedSecondaryPositions] = useState<string[]>([]);
  const [selectedNationalities, setSelectedNationalities] = useState<string[]>([]);
  const [selectedResponsibilities, setSelectedResponsibilities] = useState<string[]>([]);
  const [showNationalityPicker, setShowNationalityPicker] = useState(false);
  const [showHeightPicker, setShowHeightPicker] = useState(false);
  const [clubLogos, setClubLogos] = useState<Record<string, string>>({});
  const [allClubs, setAllClubs] = useState<string[]>([]);
  const [advisors, setAdvisors] = useState<Advisor[]>([]);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [showSpielplanModal, setShowSpielplanModal] = useState(false);
  
  // Club autocomplete state
  const [clubSearch, setClubSearch] = useState('');
  const [showClubSuggestions, setShowClubSuggestions] = useState(false);
  const [futureClubSearch, setFutureClubSearch] = useState('');
  const [showFutureClubSuggestions, setShowFutureClubSuggestions] = useState(false);

  // Clean fussball.de URL (remove Google redirect wrapper if present)
  const cleanFussballDeUrl = (url: string): string => {
    if (!url) return '';
    if (url.includes('google.com/url')) {
      const match = url.match(/[?&]q=([^&]+)/);
      if (match) return decodeURIComponent(match[1]);
    }
    return url;
  };

  // Open Spielplan - uses stored fussball_de_url
  const openSpielplan = () => {
    if (!player?.fussball_de_url) {
      Alert.alert('Kein Spielplan', 'Bitte f√ºge zuerst eine fussball.de URL hinzu (im Bearbeiten-Modus).');
      return;
    }
    const cleanUrl = cleanFussballDeUrl(player.fussball_de_url);
    Linking.openURL(cleanUrl);
  };

  useEffect(() => { fetchPlayer(); fetchClubLogos(); fetchAdvisors(); }, []);
  useEffect(() => {
    if (player) {
      setSelectedPositions(player.position ? player.position.split(', ').filter(p => POSITIONS.includes(p)) : []);
      setSelectedSecondaryPositions(player.secondary_position ? player.secondary_position.split(', ').filter(p => POSITIONS.includes(p)) : []);
      setSelectedNationalities(player.nationality ? player.nationality.split(', ').filter(n => COUNTRIES.includes(n)) : []);
      const playerResp = player.responsibility ? player.responsibility.split(', ') : [];
      setSelectedResponsibilities(playerResp);
      setClubSearch(player.club || '');
      setFutureClubSearch(player.future_club || '');
      checkAndApplyFutureClub(player);
    }
  }, [player]);

  const fetchAdvisors = async () => {
    const { data } = await supabase.from('advisors').select('id, first_name, last_name').order('last_name');
    if (data) setAdvisors(data);
  };

  const checkAndApplyFutureClub = async (p: Player) => {
    if (!p.future_club || !p.contract_end) return;
    const today = new Date();
    const contractEnd = new Date(p.contract_end);
    if (today > contractEnd) {
      const updateData: any = {
        club: p.future_club,
        future_club: null,
        contract_end: p.future_contract_end || null,
        future_contract_end: null,
      };
      await supabase.from('player_details').update(updateData).eq('id', p.id);
      fetchPlayer();
    }
  };

  const fetchClubLogos = async () => {
    const { data, error } = await supabase.from('club_logos').select('club_name, logo_url');
    if (!error && data) {
      const logoMap: Record<string, string> = {};
      const clubs: string[] = [];
      data.forEach((item: ClubLogo) => {
        logoMap[item.club_name] = item.logo_url;
        clubs.push(item.club_name);
        const simplified = item.club_name.replace(' II', '').replace(' U23', '').replace(' U21', '').replace(' U19', '');
        if (simplified !== item.club_name) logoMap[simplified] = item.logo_url;
      });
      setClubLogos(logoMap);
      setAllClubs(clubs.sort());
    }
  };

  const getClubLogo = (clubName: string): string | null => {
    if (!clubName) return null;
    if (clubLogos[clubName]) return clubLogos[clubName];
    const variations = [clubName, clubName.replace('FC ', '').replace(' FC', ''), clubName.replace('1. ', ''), clubName.replace('SV ', '').replace(' SV', ''), clubName.replace('VfB ', '').replace(' VfB', ''), clubName.replace('VfL ', '').replace(' VfL', ''), clubName.replace('TSG ', '').replace(' TSG', ''), clubName.replace('SC ', '').replace(' SC', '')];
    for (const variation of variations) { if (clubLogos[variation]) return clubLogos[variation]; }
    for (const [logoClub, logoUrl] of Object.entries(clubLogos)) {
      if (clubName.toLowerCase().includes(logoClub.toLowerCase()) || logoClub.toLowerCase().includes(clubName.toLowerCase())) return logoUrl;
    }
    return null;
  };

  const getFilteredClubs = (search: string): string[] => {
    if (!search || search.length < 2) return [];
    const searchLower = search.toLowerCase();
    return allClubs.filter(club => club.toLowerCase().includes(searchLower)).slice(0, 10);
  };

  const fetchPlayer = async () => {
    setLoading(true);
    const { data, error } = await supabase.from('player_details').select('*').eq('id', playerId).single();
    if (error) { Alert.alert('Fehler', 'Spieler konnte nicht geladen werden'); }
    else { setPlayer(data); setEditData(data); }
    setLoading(false);
  };

  const formatDate = (dateString: string) => {
    if (!dateString) return '-';
    const date = new Date(dateString);
    return `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')}.${date.getFullYear()}`;
  };

  const convertToInputDate = (dateString: string) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
  };

  const calculateAge = (birthDate: string) => {
    if (!birthDate) return '-';
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    if (today.getMonth() < birth.getMonth() || (today.getMonth() === birth.getMonth() && today.getDate() < birth.getDate())) age--;
    return age.toString();
  };

  const isBirthday = (birthDate: string): boolean => {
    if (!birthDate) return false;
    const today = new Date();
    const birth = new Date(birthDate);
    return today.getMonth() === birth.getMonth() && today.getDate() === birth.getDate();
  };

  const isContractExpired = (contractEnd: string): boolean => {
    if (!contractEnd) return false;
    const today = new Date();
    const endDate = new Date(contractEnd);
    return today > endDate;
  };

  const isYouthPlayer = (birthDate: string): boolean => {
    if (!birthDate) return false;
    const age = parseInt(calculateAge(birthDate));
    return age <= 19;
  };

  const hasFutureClubAndExpiringContract = (p: Player | null): boolean => {
    if (!p || !p.future_club || !p.contract_end) return false;
    return isContractInCurrentSeason(p.contract_end);
  };

  const calculateU23Status = (birthDate: string): { isU23: boolean; seasonsText: string } => {
    if (!birthDate) return { isU23: false, seasonsText: '' };
    const birth = new Date(birthDate);
    const birthYear = birth.getFullYear();
    const birthMonth = birth.getMonth();
    const today = new Date();
    const todayYear = today.getFullYear();
    const todayMonth = today.getMonth();
    let currentSeasonStartYear = todayMonth >= 6 ? todayYear : todayYear - 1;
    
    const getAgeOnJune30 = (year: number): number => {
      let age = year - birthYear;
      if (birthMonth > 5) age--;
      return age;
    };
    
    const ageOnJune30BeforeCurrentSeason = getAgeOnJune30(currentSeasonStartYear);
    if (ageOnJune30BeforeCurrentSeason > 22) return { isU23: false, seasonsText: '' };
    
    let seasonsLeft = 0;
    for (let i = 0; i < 15; i++) {
      const checkYear = currentSeasonStartYear + i;
      const ageOnDate = getAgeOnJune30(checkYear);
      if (ageOnDate <= 22) seasonsLeft++; else break;
    }
    
    let seasonsText = seasonsLeft === 1 ? 'nur noch diese Saison' : seasonsLeft === 2 ? 'noch eine weitere Saison' : `noch ${seasonsLeft - 1} weitere Saisons`;
    return { isU23: true, seasonsText };
  };

  const isContractInCurrentSeason = (contractEnd: string): boolean => {
    if (!contractEnd) return false;
    const today = new Date();
    const todayYear = today.getFullYear();
    const todayMonth = today.getMonth();
    let seasonStartYear = todayMonth >= 6 ? todayYear : todayYear - 1;
    let seasonEndYear = seasonStartYear + 1;
    const contractDate = new Date(contractEnd);
    const contractYear = contractDate.getFullYear();
    const contractMonth = contractDate.getMonth();
    const contractDay = contractDate.getDate();
    const afterStart = (contractYear > seasonStartYear) || (contractYear === seasonStartYear && contractMonth >= 6);
    const beforeEnd = (contractYear < seasonEndYear) || (contractYear === seasonEndYear && contractMonth < 5) || (contractYear === seasonEndYear && contractMonth === 5 && contractDay <= 30);
    return afterStart && beforeEnd;
  };

  const uploadDocument = async (field: 'contract_documents' | 'provision_documents' | 'transfer_commission_documents') => {
    try {
      const result = await DocumentPicker.getDocumentAsync({ type: 'application/pdf' });
      if (result.canceled) return;
      
      const file = result.assets[0];
      const fileName = `${playerId}/${field}/${Date.now()}_${file.name}`;
      
      const response = await fetch(file.uri);
      const blob = await response.blob();
      
      const { error: uploadError } = await supabase.storage.from('contracts').upload(fileName, blob);
      if (uploadError) { Alert.alert('Fehler', uploadError.message); return; }
      
      const { data: urlData } = supabase.storage.from('contracts').getPublicUrl(fileName);
      const currentDocs = editData?.[field] || [];
      const newDocs = [...currentDocs, { name: file.name, url: urlData.publicUrl, path: fileName }];
      updateField(field, newDocs);
      Alert.alert('Erfolg', 'Dokument hochgeladen');
    } catch (error) { Alert.alert('Fehler', 'Dokument konnte nicht hochgeladen werden'); }
  };

  const openDocument = (url: string) => { Linking.openURL(url); };

  const deleteDocumentFromField = async (path: string, field: 'contract_documents' | 'provision_documents' | 'transfer_commission_documents') => {
    const { error } = await supabase.storage.from('contracts').remove([path]);
    if (!error) {
      const newDocs = (editData?.[field] || []).filter((doc: any) => doc.path !== path);
      updateField(field, newDocs);
    }
  };

  const togglePosition = (pos: string) => { const newPositions = selectedPositions.includes(pos) ? selectedPositions.filter(p => p !== pos) : [...selectedPositions, pos]; setSelectedPositions(newPositions); updateField('position', newPositions.join(', ')); };
  const toggleSecondaryPosition = (pos: string) => { const newPositions = selectedSecondaryPositions.includes(pos) ? selectedSecondaryPositions.filter(p => p !== pos) : [...selectedSecondaryPositions, pos]; setSelectedSecondaryPositions(newPositions); updateField('secondary_position', newPositions.join(', ')); };
  const toggleNationality = (country: string) => { const newNationalities = selectedNationalities.includes(country) ? selectedNationalities.filter(c => c !== country) : [...selectedNationalities, country]; setSelectedNationalities(newNationalities); updateField('nationality', newNationalities.join(', ')); };
  const toggleResponsibility = (name: string) => { 
    const newResponsibilities = selectedResponsibilities.includes(name) 
      ? selectedResponsibilities.filter(p => p !== name) 
      : [...selectedResponsibilities, name]; 
    setSelectedResponsibilities(newResponsibilities); 
    updateField('responsibility', newResponsibilities.join(', ')); 
  };
  const updateField = (field: string, value: any) => { if (editData) setEditData({ ...editData, [field]: value }); };

  const handleSave = async () => {
    if (!editData) return;
    const u23Status = calculateU23Status(editData.birth_date);
    const updateData: any = {
      first_name: editData.first_name, last_name: editData.last_name, nationality: selectedNationalities.join(', ') || null, birth_date: editData.birth_date || null, club: editData.club || null, league: editData.league || null, position: selectedPositions.join(', ') || null, contract_end: editData.contract_end || null, photo_url: editData.photo_url || null, strong_foot: editData.strong_foot || null, height: editData.height || null, secondary_position: selectedSecondaryPositions.join(', ') || null, salary_month: editData.salary_month || null, point_bonus: editData.point_bonus || null, appearance_bonus: editData.appearance_bonus || null, contract_option: editData.contract_option || null, contract_scope: editData.contract_scope || null, fixed_fee: editData.fixed_fee || null, contract_notes: editData.contract_notes || null, u23_player: u23Status.isU23, provision: editData.provision || null, transfer_commission: editData.transfer_commission || null, mandate_until: editData.mandate_until || null, responsibility: selectedResponsibilities.join(', ') || null, listing: editData.listing || null, phone: editData.phone || null, phone_country_code: editData.phone_country_code || '+49', email: editData.email || null, education: editData.education || null, training: editData.training || null, instagram: editData.instagram || null, linkedin: editData.linkedin || null, tiktok: editData.tiktok || null, transfermarkt_url: editData.transfermarkt_url || null, interests: editData.interests || null, father_name: editData.father_name || null, father_phone: editData.father_phone || null, father_phone_country_code: editData.father_phone_country_code || '+49', father_job: editData.father_job || null, mother_name: editData.mother_name || null, mother_phone: editData.mother_phone || null, mother_phone_country_code: editData.mother_phone_country_code || '+49', mother_job: editData.mother_job || null, siblings: editData.siblings || null, other_notes: editData.other_notes || null, injuries: editData.injuries || null, street: editData.street || null, postal_code: editData.postal_code || null, city: editData.city || null, internat: editData.internat || false, future_club: editData.future_club || null, future_contract_end: editData.future_contract_end || null, contract_documents: editData.contract_documents || [], provision_documents: editData.provision_documents || [], transfer_commission_documents: editData.transfer_commission_documents || [], fussball_de_url: editData.fussball_de_url || null,
    };
    const { error } = await supabase.from('player_details').update(updateData).eq('id', playerId);
    if (error) Alert.alert('Fehler', error.message);
    else { Alert.alert('Erfolg', 'Spieler wurde gespeichert'); setEditing(false); fetchPlayer(); }
  };

  const confirmDelete = async () => {
    try {
      await supabase.from('player_access').delete().eq('player_id', playerId);
      const { error } = await supabase.from('player_details').delete().eq('id', playerId);
      if (error) { 
        Alert.alert('Fehler', error.message); 
        setShowDeleteModal(false); 
      } else { 
        setShowDeleteModal(false); 
        navigation.popToTop();
      }
    } catch (err) { 
      Alert.alert('Fehler', 'Spieler konnte nicht gel√∂scht werden'); 
      setShowDeleteModal(false); 
    }
  };

  const renderField = (label: string, field: keyof Player, placeholder?: string) => (
    <View style={styles.infoRow}>
      <Text style={styles.label}>{label}</Text>
      {editing ? <TextInput style={styles.input} value={editData?.[field]?.toString() || ''} onChangeText={(text) => updateField(field, text)} placeholder={placeholder || label} /> : <Text style={styles.value}>{player?.[field]?.toString() || '-'}</Text>}
    </View>
  );

  const renderSpielplanButton = () => {
    // Extract team level from league (e.g., "U17 Bundesliga" -> "U17")
    const teamMatch = player?.league?.match(/U\d+/i);
    const teamLevel = teamMatch ? teamMatch[0] : '';
    const clubName = player?.club || '';
    const displayName = `${clubName}${teamLevel ? ' ' + teamLevel : ''}`.trim();
    
    if (editing) {
      return (
        <View style={styles.infoRow}>
          <Text style={styles.label}>Spielplan (fussball.de)</Text>
          <TextInput 
            style={styles.input} 
            value={editData?.fussball_de_url || ''} 
            onChangeText={(text) => updateField('fussball_de_url', text)} 
            placeholder="https://www.fussball.de/mannschaft/..." 
          />
          <Text style={styles.spielplanHint}>
            üí° Gehe auf fussball.de ‚Üí Suche die Mannschaft ‚Üí Kopiere die URL
          </Text>
        </View>
      );
    }
    
    if (!player?.fussball_de_url) {
      return (
        <View style={styles.infoRow}>
          <Text style={styles.label}>Spielplan</Text>
          <Text style={styles.valueGray}>Keine URL hinterlegt</Text>
        </View>
      );
    }
    
    return (
      <View style={styles.infoRow}>
        <Text style={styles.label}>Spielplan</Text>
        <TouchableOpacity 
          style={styles.spielplanButton} 
          onPress={openSpielplan}
        >
          <Text style={styles.spielplanButtonText}>
            üìÖ Spielplan {displayName}
          </Text>
        </TouchableOpacity>
      </View>
    );
  };

  const renderClubField = () => {
    const filteredClubs = getFilteredClubs(clubSearch);
    const logoUrl = getClubLogo(clubSearch);
    const contractExpired = isContractExpired(player?.contract_end || '');
    const displayClub = contractExpired ? 'Vereinslos' : player?.club;
    
    return (
      <View style={[styles.infoRow, { zIndex: 200 }]}>
        <Text style={styles.label}>Verein</Text>
        {editing ? (
          <View style={styles.autocompleteContainer}>
            <View style={styles.clubInputRow}>
              {logoUrl && <Image source={{ uri: logoUrl }} style={styles.clubLogoInput} />}
              <TextInput 
                style={[styles.input, styles.clubInput]} 
                value={clubSearch} 
                onChangeText={(text) => { 
                  setClubSearch(text); 
                  updateField('club', text); 
                  setShowClubSuggestions(true);
                  setShowFutureClubSuggestions(false);
                }} 
                onFocus={() => { setShowClubSuggestions(true); setShowFutureClubSuggestions(false); }}
                onBlur={() => setTimeout(() => setShowClubSuggestions(false), 200)}
                placeholder="Verein eingeben..." 
              />
            </View>
            {showClubSuggestions && filteredClubs.length > 0 && (
              <View style={styles.suggestionsList}>
                <ScrollView style={styles.suggestionsScroll} nestedScrollEnabled keyboardShouldPersistTaps="handled">
                  {filteredClubs.map((club) => (
                    <TouchableOpacity 
                      key={club} 
                      style={styles.suggestionItem}
                      onPress={() => { 
                        setClubSearch(club); 
                        updateField('club', club); 
                        setShowClubSuggestions(false); 
                      }}
                    >
                      <Text style={styles.suggestionText}>{club}</Text>
                    </TouchableOpacity>
                  ))}
                </ScrollView>
              </View>
            )}
          </View>
        ) : (
          <View style={styles.clubRowSmall}>
            {contractExpired ? (
              <Image source={ArbeitsamtIcon} style={styles.clubLogoSmall} />
            ) : getClubLogo(player?.club || '') ? (
              <Image source={{ uri: getClubLogo(player?.club || '')! }} style={styles.clubLogoSmall} />
            ) : null}
            <Text style={[styles.value, contractExpired && styles.clubTextRed]}>{displayClub || '-'}</Text>
          </View>
        )}
      </View>
    );
  };

  const renderFutureClubField = () => {
    const showField = editing || player?.future_club;
    if (!showField) return null;
    
    const filteredClubs = getFilteredClubs(futureClubSearch);
    const logoUrl = getClubLogo(futureClubSearch || player?.future_club || '');
    
    return (
      <View style={[styles.infoRow, { zIndex: 100 }]}>
        <Text style={styles.label}>Zuk√ºnftiger Verein</Text>
        {editing ? (
          <View style={styles.autocompleteContainer}>
            <View style={styles.clubInputRow}>
              {logoUrl && <Image source={{ uri: logoUrl }} style={styles.clubLogoInput} />}
              <TextInput 
                style={[styles.input, styles.clubInput]} 
                value={futureClubSearch} 
                onChangeText={(text) => { 
                  setFutureClubSearch(text); 
                  updateField('future_club', text); 
                  setShowFutureClubSuggestions(true);
                  setShowClubSuggestions(false);
                }}
                onFocus={() => { setShowFutureClubSuggestions(true); setShowClubSuggestions(false); }}
                onBlur={() => setTimeout(() => setShowFutureClubSuggestions(false), 200)}
                placeholder="Zuk√ºnftiger Verein eingeben..." 
              />
            </View>
            {showFutureClubSuggestions && filteredClubs.length > 0 && (
              <View style={styles.suggestionsList}>
                <ScrollView style={styles.suggestionsScroll} nestedScrollEnabled keyboardShouldPersistTaps="handled">
                  {filteredClubs.map((club) => (
                    <TouchableOpacity 
                      key={club} 
                      style={styles.suggestionItem}
                      onPress={() => { 
                        setFutureClubSearch(club); 
                        updateField('future_club', club); 
                        setShowFutureClubSuggestions(false); 
                      }}
                    >
                      <Text style={styles.suggestionText}>{club}</Text>
                    </TouchableOpacity>
                  ))}
                </ScrollView>
              </View>
            )}
            {(futureClubSearch || editData?.future_club) && (
              <View style={styles.futureContractRow}>
                <Text style={styles.smallLabel}>Zuk√ºnftiges Vertragsende:</Text>
                <input type="date" style={{ padding: 8, fontSize: 14, borderRadius: 8, border: '1px solid #ddd', flex: 1, boxSizing: 'border-box' as const }} value={convertToInputDate(editData?.future_contract_end || '')} onChange={(e) => updateField('future_contract_end', e.target.value)} />
              </View>
            )}
          </View>
        ) : (
          <View style={styles.clubRowSmall}>
            {logoUrl && <Image source={{ uri: logoUrl }} style={styles.clubLogoSmall} />}
            <Text style={styles.value}>{player?.future_club || '-'}</Text>
          </View>
        )}
      </View>
    );
  };

  const renderFieldWithDocuments = (label: string, field: keyof Player, docField: 'provision_documents' | 'transfer_commission_documents') => (
    <View style={styles.infoRow}>
      <Text style={styles.label}>{label}</Text>
      {editing ? (
        <View>
          <TextInput style={styles.input} value={editData?.[field]?.toString() || ''} onChangeText={(text) => updateField(field, text)} placeholder={label} />
          <TouchableOpacity style={styles.smallUploadButton} onPress={() => uploadDocument(docField)}>
            <Text style={styles.smallUploadButtonText}>+ PDF</Text>
          </TouchableOpacity>
          {(editData?.[docField] || []).map((doc: any, index: number) => (
            <View key={index} style={styles.smallDocItem}>
              <TouchableOpacity onPress={() => openDocument(doc.url)} style={styles.documentLink}>
                <Text style={styles.smallDocName}>üìÑ {doc.name}</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={() => deleteDocumentFromField(doc.path, docField)} style={styles.documentDelete}>
                <Text style={styles.documentDeleteText}>‚úï</Text>
              </TouchableOpacity>
            </View>
          ))}
        </View>
      ) : (
        <View>
          <Text style={styles.value}>{player?.[field]?.toString() || '-'}</Text>
          {(player?.[docField] || []).map((doc: any, index: number) => (
            <TouchableOpacity key={index} onPress={() => openDocument(doc.url)}>
              <Text style={styles.docLink}>üìÑ {doc.name}</Text>
            </TouchableOpacity>
          ))}
        </View>
      )}
    </View>
  );

  const renderPhoneField = (label: string, phoneField: keyof Player, codeField: keyof Player) => (
    <View style={styles.infoRow}>
      <Text style={styles.label}>{label}</Text>
      {editing ? (
        <View style={styles.phoneContainer}>
          <View style={styles.phoneCodePicker}>
            <select style={{ padding: 10, fontSize: 14, borderRadius: 8, border: '1px solid #ddd', width: '100%' }} value={editData?.[codeField]?.toString() || '+49'} onChange={(e) => updateField(codeField, e.target.value)}>
              {COUNTRY_CODES.map((c) => (<option key={c.code} value={c.code}>{c.code} ({c.country})</option>))}
            </select>
          </View>
          <TextInput style={[styles.input, styles.phoneInput]} value={editData?.[phoneField]?.toString() || ''} onChangeText={(text) => updateField(phoneField, text)} placeholder="Telefonnummer" keyboardType="phone-pad" />
        </View>
      ) : (<Text style={styles.value}>{player?.[phoneField] ? `${player?.[codeField] || '+49'} ${player?.[phoneField]}` : '-'}</Text>)}
    </View>
  );

  const renderDateField = (label: string, field: keyof Player) => (
    <View style={styles.infoRow}>
      <Text style={styles.label}>{label}</Text>
      {editing ? <input type="date" style={{ padding: 12, fontSize: 15, borderRadius: 8, border: '1px solid #ddd', width: '100%', boxSizing: 'border-box' as const }} value={convertToInputDate(editData?.[field] as string || '')} onChange={(e) => updateField(field, e.target.value)} /> : <Text style={styles.value}>{player?.[field] ? formatDate(player[field] as string) : '-'}</Text>}
    </View>
  );

  const renderBirthDateField = () => {
    const birthday = isBirthday(player?.birth_date || '');
    return (
      <View style={styles.infoRow}>
        <Text style={styles.label}>Geburtsdatum</Text>
        {editing ? (
          <input type="date" style={{ padding: 12, fontSize: 15, borderRadius: 8, border: '1px solid #ddd', width: '100%', boxSizing: 'border-box' as const }} value={convertToInputDate(editData?.birth_date || '')} onChange={(e) => updateField('birth_date', e.target.value)} />
        ) : (
          <View style={styles.birthdayRow}>
            <Text style={styles.value}>{player?.birth_date ? formatDate(player.birth_date) : '-'}</Text>
            {birthday && <Text style={styles.birthdayIcon}>üéâ</Text>}
          </View>
        )}
      </View>
    );
  };

  const renderContractEndField = () => {
    const inCurrentSeason = isContractInCurrentSeason(player?.contract_end || '');
    const hasSecuredFuture = hasFutureClubAndExpiringContract(player);
    return (
      <View style={styles.infoRow}>
        <Text style={styles.label}>Vertragsende</Text>
        {editing ? (<input type="date" style={{ padding: 12, fontSize: 15, borderRadius: 8, border: '1px solid #ddd', width: '100%', boxSizing: 'border-box' as const }} value={convertToInputDate(editData?.contract_end || '')} onChange={(e) => updateField('contract_end', e.target.value)} />
        ) : player?.contract_end ? (<View style={[styles.statusBadge, hasSecuredFuture ? styles.statusBadgeGreen : (inCurrentSeason ? styles.statusBadgeRed : styles.statusBadgeNormal)]}><Text style={[styles.statusBadgeText, hasSecuredFuture ? styles.statusTextGreen : (inCurrentSeason ? styles.statusTextRed : styles.statusTextNormal)]}>{formatDate(player.contract_end)}</Text></View>) : <Text style={styles.value}>-</Text>}
      </View>
    );
  };

  const renderAddressField = () => (
    <View style={styles.infoRow}>
      <Text style={styles.label}>Adresse</Text>
      {editing ? (
        <View style={styles.addressRow}>
          <TextInput style={[styles.input, styles.addressStreet]} value={editData?.street || ''} onChangeText={(text) => updateField('street', text)} placeholder="Stra√üe" />
          <TextInput style={[styles.input, styles.addressPLZ]} value={editData?.postal_code || ''} onChangeText={(text) => updateField('postal_code', text)} placeholder="PLZ" />
          <TextInput style={[styles.input, styles.addressCity]} value={editData?.city || ''} onChangeText={(text) => updateField('city', text)} placeholder="Wohnort" />
        </View>
      ) : (
        <Text style={styles.value}>
          {player?.street || player?.postal_code || player?.city 
            ? `${player?.street || ''}${player?.street && (player?.postal_code || player?.city) ? ', ' : ''}${player?.postal_code || ''} ${player?.city || ''}`.trim() 
            : '-'}
        </Text>
      )}
    </View>
  );

  const renderPositionSelector = (label: string, selected: string[], toggle: (pos: string) => void) => (
    <View style={styles.infoRow}>
      <Text style={styles.label}>{label}</Text>
      {editing ? (<View style={styles.chipGrid}>{POSITIONS.map((pos) => (<TouchableOpacity key={pos} style={[styles.chip, selected.includes(pos) && styles.chipSelected]} onPress={() => toggle(pos)}><Text style={[styles.chipText, selected.includes(pos) && styles.chipTextSelected]}>{selected.includes(pos) ? '‚úì ' : ''}{pos}</Text></TouchableOpacity>))}</View>) : <Text style={styles.value}>{selected.length > 0 ? selected.join(', ') : '-'}</Text>}
    </View>
  );

  const renderResponsibilitySelector = () => {
    const advisorNames = advisors.map(a => `${a.first_name} ${a.last_name}`.trim());
    return (
      <View style={styles.infoRow}>
        <Text style={styles.label}>Zust√§ndigkeit</Text>
        {editing ? (
          <View style={styles.chipGrid}>
            {advisorNames.map((name) => (
              <TouchableOpacity 
                key={name} 
                style={[styles.chip, selectedResponsibilities.includes(name) && styles.chipSelected]} 
                onPress={() => toggleResponsibility(name)}
              >
                <Text style={[styles.chipText, selectedResponsibilities.includes(name) && styles.chipTextSelected]}>
                  {selectedResponsibilities.includes(name) ? '‚úì ' : ''}{name}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        ) : (
          <Text style={styles.value}>{selectedResponsibilities.length > 0 ? selectedResponsibilities.join(', ') : '-'}</Text>
        )}
      </View>
    );
  };

  const renderNationalitySelector = () => (
    <View style={styles.infoRow}>
      <Text style={styles.label}>Nationalit√§t</Text>
      {editing ? (<View><TouchableOpacity style={styles.dropdownButton} onPress={() => setShowNationalityPicker(!showNationalityPicker)}><Text style={styles.dropdownButtonText}>{selectedNationalities.length > 0 ? selectedNationalities.join(', ') : 'Nationalit√§t w√§hlen...'}</Text><Text>{showNationalityPicker ? '‚ñ≤' : '‚ñº'}</Text></TouchableOpacity>{showNationalityPicker && (<View style={styles.pickerList}><ScrollView style={styles.pickerScroll} nestedScrollEnabled>{COUNTRIES.map((country) => (<TouchableOpacity key={country} style={[styles.pickerItem, selectedNationalities.includes(country) && styles.pickerItemSelected]} onPress={() => toggleNationality(country)}><Text style={[styles.pickerItemText, selectedNationalities.includes(country) && styles.pickerItemTextSelected]}>{selectedNationalities.includes(country) ? '‚úì ' : ''}{country}</Text></TouchableOpacity>))}</ScrollView></View>)}</View>) : <Text style={styles.value}>{selectedNationalities.length > 0 ? selectedNationalities.join(', ') : '-'}</Text>}
    </View>
  );

  const renderStrongFootSelector = () => (
    <View style={styles.infoRow}>
      <Text style={styles.label}>Starker Fu√ü</Text>
      {editing ? (<View style={styles.footSelector}>{['Links', 'Rechts', 'Beidf√º√üig'].map((foot) => (<TouchableOpacity key={foot} style={[styles.footOption, editData?.strong_foot === foot && styles.footOptionSelected]} onPress={() => updateField('strong_foot', foot)}><Text style={[styles.footOptionText, editData?.strong_foot === foot && styles.footOptionTextSelected]}>{foot}</Text></TouchableOpacity>))}</View>) : <Text style={styles.value}>{player?.strong_foot || '-'}</Text>}
    </View>
  );

  const renderHeightSelector = () => (
    <View style={styles.infoRow}>
      <Text style={styles.label}>Gr√∂√üe</Text>
      {editing ? (<View><TouchableOpacity style={styles.dropdownButton} onPress={() => setShowHeightPicker(!showHeightPicker)}><Text style={styles.dropdownButtonText}>{editData?.height ? `${editData.height} cm` : 'Gr√∂√üe w√§hlen...'}</Text><Text>{showHeightPicker ? '‚ñ≤' : '‚ñº'}</Text></TouchableOpacity>{showHeightPicker && (<View style={styles.pickerList}><ScrollView style={styles.pickerScroll} nestedScrollEnabled>{HEIGHTS.map((h) => (<TouchableOpacity key={h} style={[styles.pickerItem, editData?.height === h && styles.pickerItemSelected]} onPress={() => { updateField('height', h); setShowHeightPicker(false); }}><Text style={[styles.pickerItemText, editData?.height === h && styles.pickerItemTextSelected]}>{h} cm</Text></TouchableOpacity>))}</ScrollView></View>)}</View>) : <Text style={styles.value}>{player?.height ? `${player.height} cm` : '-'}</Text>}
    </View>
  );

  const renderU23Status = () => {
    const u23Status = calculateU23Status(player?.birth_date || '');
    return (<View style={styles.infoRow}><Text style={styles.label}>U23-Spieler</Text><View style={[styles.statusBadge, u23Status.isU23 ? styles.statusBadgeGreen : styles.statusBadgeRed]}><Text style={[styles.statusBadgeText, u23Status.isU23 ? styles.statusTextGreen : styles.statusTextRed]}>{u23Status.isU23 ? `Ja (${u23Status.seasonsText})` : 'Nein'}</Text></View></View>);
  };

  const renderInternatField = () => {
    if (!isYouthPlayer(player?.birth_date || '')) return null;
    return (
      <View style={styles.infoRow}>
        <Text style={styles.label}>Internat</Text>
        {editing ? (
          <View style={styles.footSelector}>
            {['Ja', 'Nein'].map((opt) => (
              <TouchableOpacity key={opt} style={[styles.footOption, (editData?.internat ? 'Ja' : 'Nein') === opt && styles.footOptionSelected]} onPress={() => updateField('internat', opt === 'Ja')}>
                <Text style={[styles.footOptionText, (editData?.internat ? 'Ja' : 'Nein') === opt && styles.footOptionTextSelected]}>{opt}</Text>
              </TouchableOpacity>
            ))}
          </View>
        ) : <Text style={styles.value}>{player?.internat ? 'Ja' : 'Nein'}</Text>}
      </View>
    );
  };

  const renderSocialLinks = () => {
    const hasAnySocial = player?.instagram || player?.linkedin || player?.tiktok;
    if (!hasAnySocial && !editing) return null;
    return (
      <View style={styles.infoRow}>
        <Text style={styles.label}>Social Media</Text>
        {editing ? (<View><View style={styles.socialInputRow}><Image source={InstagramIcon} style={styles.socialIconSmall} /><TextInput style={[styles.input, styles.socialInput]} value={editData?.instagram || ''} onChangeText={(text) => updateField('instagram', text)} placeholder="Instagram @username" /></View><View style={styles.socialInputRow}><Image source={LinkedInIcon} style={styles.socialIconSmall} /><TextInput style={[styles.input, styles.socialInput]} value={editData?.linkedin || ''} onChangeText={(text) => updateField('linkedin', text)} placeholder="LinkedIn URL" /></View><View style={styles.socialInputRow}><Image source={TikTokIcon} style={styles.socialIconSmall} /><TextInput style={[styles.input, styles.socialInput]} value={editData?.tiktok || ''} onChangeText={(text) => updateField('tiktok', text)} placeholder="TikTok @username" /></View></View>
        ) : (<View style={styles.socialIconsRow}>{player?.instagram && <TouchableOpacity onPress={() => Linking.openURL(player.instagram.startsWith('http') ? player.instagram : `https://instagram.com/${player.instagram.replace('@', '')}`)}><Image source={InstagramIcon} style={styles.socialIcon} /></TouchableOpacity>}{player?.linkedin && <TouchableOpacity onPress={() => Linking.openURL(player.linkedin.startsWith('http') ? player.linkedin : `https://linkedin.com/in/${player.linkedin}`)}><Image source={LinkedInIcon} style={styles.socialIcon} /></TouchableOpacity>}{player?.tiktok && <TouchableOpacity onPress={() => Linking.openURL(player.tiktok.startsWith('http') ? player.tiktok : `https://tiktok.com/@${player.tiktok.replace('@', '')}`)}><Image source={TikTokIcon} style={styles.socialIcon} /></TouchableOpacity>}</View>)}
      </View>
    );
  };

  const renderDocuments = () => (
    <View style={styles.infoRow}>
      <Text style={styles.label}>Vertragsunterlagen</Text>
      {editing && (<TouchableOpacity style={styles.uploadButton} onPress={() => uploadDocument('contract_documents')}><Text style={styles.uploadButtonText}>+ PDF hochladen</Text></TouchableOpacity>)}
      <View style={styles.documentList}>
        {(player?.contract_documents || []).map((doc: any, index: number) => (
          <View key={index} style={styles.documentItem}>
            <TouchableOpacity onPress={() => openDocument(doc.url)} style={styles.documentLink}>
              <Text style={styles.documentIcon}>üìÑ</Text>
              <Text style={styles.documentName}>{doc.name}</Text>
            </TouchableOpacity>
            {editing && (<TouchableOpacity onPress={() => deleteDocumentFromField(doc.path, 'contract_documents')} style={styles.documentDelete}><Text style={styles.documentDeleteText}>‚úï</Text></TouchableOpacity>)}
          </View>
        ))}
      </View>
    </View>
  );

  const renderDeleteModal = () => (
    <Modal visible={showDeleteModal} transparent animationType="fade">
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <Text style={styles.modalTitle}>Spieler l√∂schen</Text>
          <Text style={styles.modalText}>M√∂chten Sie {player?.first_name} {player?.last_name} wirklich l√∂schen?</Text>
          <View style={styles.modalButtons}>
            <TouchableOpacity style={styles.modalCancelButton} onPress={() => setShowDeleteModal(false)}>
              <Text style={styles.modalCancelButtonText}>Abbrechen</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.modalDeleteButton} onPress={confirmDelete}>
              <Text style={styles.modalDeleteButtonText}>L√∂schen</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  if (loading) return (
    <View style={styles.modalOverlayContainer}>
      <View style={styles.modalContainer}>
        <Text style={styles.loadingText}>Laden...</Text>
      </View>
    </View>
  );
  if (!player || !editData) return (
    <View style={styles.modalOverlayContainer}>
      <TouchableOpacity style={styles.modalBackdrop} onPress={() => navigation.goBack()} activeOpacity={1} />
      <View style={styles.modalContainer}>
        <Text style={styles.loadingText}>Spieler nicht gefunden</Text>
      </View>
    </View>
  );

  const contractExpired = isContractExpired(player.contract_end);
  const displayClub = contractExpired ? 'Vereinslos' : player.club;
  const birthday = isBirthday(player.birth_date);
  const futureClubLogo = getClubLogo(player.future_club || '');

  return (
    <View style={styles.modalOverlayContainer}>
      <TouchableOpacity style={styles.modalBackdrop} onPress={() => navigation.goBack()} activeOpacity={1} />
      <View style={styles.modalContainer}>
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Spielerinfo</Text>
          <TouchableOpacity onPress={() => navigation.goBack()} style={styles.closeButton}><Text style={styles.closeButtonText}>‚úï</Text></TouchableOpacity>
        </View>
        <ScrollView style={styles.content}>
        {/* Redesigned Top Section */}
        <View style={styles.topSection}>
          <View style={styles.topLeft}>
            <View style={styles.photoContainer}>
              {player.photo_url ? <Image source={{ uri: player.photo_url }} style={styles.photo} /> : <View style={styles.photoPlaceholder}><Text style={styles.photoPlaceholderText}>Foto</Text></View>}
            </View>
            {editing && <TextInput style={styles.photoInput} placeholder="Foto-URL" value={editData.photo_url || ''} onChangeText={(text) => updateField('photo_url', text)} />}
          </View>
          
          <View style={styles.topCenter}>
            {editing ? (
              <>
                <TextInput style={styles.nameInput} value={editData.first_name} onChangeText={(text) => updateField('first_name', text)} placeholder="Vorname" />
                <TextInput style={styles.nameInput} value={editData.last_name} onChangeText={(text) => updateField('last_name', text)} placeholder="Nachname" />
                <TextInput style={styles.tmInputTop} value={editData.transfermarkt_url || ''} onChangeText={(text) => updateField('transfermarkt_url', text)} placeholder="Transfermarkt URL" />
              </>
            ) : (
              <>
                <Text style={styles.playerFirstName}>{player.first_name}</Text>
                <Text style={styles.playerLastName}>{player.last_name}</Text>
                <View style={styles.ageRow}>
                  <Text style={styles.ageText}>{calculateAge(player.birth_date)} Jahre</Text>
                  {birthday && <Text style={styles.birthdayIconLarge}>üéâ</Text>}
                </View>
              </>
            )}
          </View>
          
          <View style={styles.topRight}>
            <View style={styles.clubSection}>
              {contractExpired ? (
                <Image source={ArbeitsamtIcon} style={styles.clubLogoHeader} />
              ) : getClubLogo(player.club) ? (
                <Image source={{ uri: getClubLogo(player.club)! }} style={styles.clubLogoHeader} />
              ) : (
                <Text style={styles.clubNameHeaderNoLogo}>{displayClub || '-'}</Text>
              )}
              {player.future_club && !editing && futureClubLogo && (
                <View style={styles.futureClubHeader}>
                  <Text style={styles.greenArrow}>‚Üí</Text>
                  <Image source={{ uri: futureClubLogo }} style={styles.futureClubLogoHeader} />
                </View>
              )}
              {player.future_club && !editing && !futureClubLogo && (
                <View style={styles.futureClubHeader}>
                  <Text style={styles.greenArrow}>‚Üí</Text>
                  <Text style={styles.futureClubNameHeader}>{player.future_club}</Text>
                </View>
              )}
            </View>
            {player.transfermarkt_url && !editing && (
              <TouchableOpacity onPress={() => Linking.openURL(player.transfermarkt_url)} style={styles.tmButton}>
                <Image source={TransfermarktIcon} style={styles.transfermarktIcon} />
              </TouchableOpacity>
            )}
          </View>
        </View>

        <View style={styles.twoColumnContainer}>
          <View style={styles.halfColumn}>
            <View style={styles.card}>
              <Text style={styles.cardTitle}>Allgemein</Text>
              {renderPositionSelector('Position', selectedPositions, togglePosition)}
              {renderPositionSelector('Nebenposition', selectedSecondaryPositions, toggleSecondaryPosition)}
              {renderNationalitySelector()}
              {renderStrongFootSelector()}
              {renderHeightSelector()}
            </View>
            <View style={styles.card}>
              <Text style={styles.cardTitle}>Beratung</Text>
              <View style={styles.infoRow}>
                <Text style={styles.label}>Listung</Text>
                {editing ? (<View style={styles.chipGrid}>{LISTINGS.map((opt) => (<TouchableOpacity key={opt} style={[styles.chip, editData?.listing === opt && styles.chipSelected]} onPress={() => updateField('listing', editData?.listing === opt ? null : opt)}><Text style={[styles.chipText, editData?.listing === opt && styles.chipTextSelected]}>{editData?.listing === opt ? '‚úì ' : ''}{opt}</Text></TouchableOpacity>))}</View>
                ) : player?.listing ? (<View style={[styles.listingBadge, player.listing === 'Karl Herzog Sportmanagement' ? styles.listingKMH : styles.listingPM]}><Text style={styles.listingBadgeText}>{player.listing}</Text></View>) : <Text style={styles.value}>-</Text>}
              </View>
              {renderResponsibilitySelector()}
              {renderDateField('Mandat g√ºltig bis', 'mandate_until')}
              {renderFieldWithDocuments('Provision', 'provision', 'provision_documents')}
              {renderFieldWithDocuments('Weg-Vermittlung', 'transfer_commission', 'transfer_commission_documents')}
            </View>
            <View style={styles.card}>
              <Text style={styles.cardTitle}>Privat</Text>
              <View style={styles.splitContainer}>
                <View style={styles.splitColumn}>
                  {renderBirthDateField()}
                  {renderPhoneField('Telefon', 'phone', 'phone_country_code')}
                  {renderField('E-Mail', 'email')}
                  {renderAddressField()}
                  {renderInternatField()}
                </View>
                <View style={styles.splitColumn}>
                  {renderField('Schulabschluss', 'education')}
                  {renderField('Ausbildung/Studium', 'training')}
                  {renderSocialLinks()}
                  {renderField('Weitere Interessen', 'interests')}
                </View>
              </View>
            </View>
          </View>
          <View style={[styles.halfColumn, { zIndex: 100 }]}>
            <View style={[styles.card, { zIndex: 100, overflow: 'visible' }]}>
              <Text style={styles.cardTitle}>Vertrag</Text>
              <View style={[styles.splitContainer, { overflow: 'visible' }]}>
                <View style={[styles.splitColumn, { overflow: 'visible', zIndex: 100 }]}>
                  {renderClubField()}
                  {renderFutureClubField()}
                  {renderField('Liga', 'league')}
                  {renderU23Status()}
                  {renderContractEndField()}
                  {renderField('Vertrag gilt f√ºr', 'contract_scope')}
                  {renderField('Option', 'contract_option')}
                  {renderField('Fixe Abl√∂se / Ausbildungsentsch√§digung', 'fixed_fee')}
                </View>
                <View style={styles.splitColumn}>
                  {renderField('Gehalt/Monat', 'salary_month')}
                  {renderField('Punktpr√§mie', 'point_bonus')}
                  {renderField('Auflaufpr√§mie', 'appearance_bonus')}
                  <View style={styles.infoRow}><Text style={styles.label}>Sonstiges</Text>{editing ? <TextInput style={[styles.input, styles.smallTextArea]} value={editData.contract_notes || ''} onChangeText={(text) => updateField('contract_notes', text)} placeholder="Sonstiges..." multiline /> : <Text style={styles.value}>{player.contract_notes || '-'}</Text>}</View>
                  {renderDocuments()}
                  {renderSpielplanButton()}
                </View>
              </View>
            </View>
            <View style={styles.card}>
              <Text style={styles.cardTitle}>Familie</Text>
              <View style={styles.familyContainer}>
                <View style={styles.familyColumn}>
                  <Text style={styles.sectionSubtitle}>Vater</Text>
                  {renderField('Name', 'father_name')}
                  {renderPhoneField('Telefon', 'father_phone', 'father_phone_country_code')}
                  {renderField('Job', 'father_job')}
                  <Text style={styles.sectionSubtitle}>Mutter</Text>
                  {renderField('Name', 'mother_name')}
                  {renderPhoneField('Telefon', 'mother_phone', 'mother_phone_country_code')}
                  {renderField('Job', 'mother_job')}
                </View>
                <View style={styles.familyColumn}>
                  <Text style={styles.sectionSubtitle}>Geschwister</Text>
                  {renderField('Name', 'siblings')}
                  <View style={styles.infoRow}><Text style={styles.label}> </Text><Text style={styles.value}> </Text></View>
                  <View style={styles.infoRow}><Text style={styles.label}> </Text><Text style={styles.value}> </Text></View>
                  <Text style={styles.sectionSubtitle}>Sonstiges</Text>
                  <View style={styles.infoRow}>{editing ? <TextInput style={[styles.input, styles.smallTextArea]} value={editData.other_notes || ''} onChangeText={(text) => updateField('other_notes', text)} placeholder="Sonstiges..." multiline /> : <Text style={styles.value}>{player.other_notes || '-'}</Text>}</View>
                </View>
              </View>
            </View>
          </View>
        </View>
        <View style={styles.cardFullWidth}>
          <Text style={styles.cardTitle}>Verletzungen & Krankheiten</Text>
          <View style={styles.infoRow}>{editing ? <TextInput style={[styles.input, styles.textArea]} value={editData.injuries || ''} onChangeText={(text) => updateField('injuries', text)} placeholder="Verletzungshistorie..." multiline /> : <Text style={styles.value}>{player.injuries || '-'}</Text>}</View>
        </View>
      </ScrollView>
      <View style={styles.bottomButtons}>
        {editing ? (
          <>
            <TouchableOpacity style={styles.deleteButton} onPress={() => setShowDeleteModal(true)}>
              <Text style={styles.deleteButtonText}>L√∂schen</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.cancelButton} onPress={() => { setEditing(false); setEditData(player); setClubSearch(player.club || ''); setFutureClubSearch(player.future_club || ''); fetchPlayer(); }}>
              <Text style={styles.cancelButtonText}>Abbrechen</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.saveButton} onPress={handleSave}>
              <Text style={styles.saveButtonText}>Speichern</Text>
            </TouchableOpacity>
          </>
        ) : (
          <TouchableOpacity style={styles.editButton} onPress={() => setEditing(true)}>
            <Text style={styles.editButtonText}>Bearbeiten</Text>
          </TouchableOpacity>
        )}
      </View>
      {renderDeleteModal()}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  // Modal Overlay Container
  modalOverlayContainer: { 
    flex: 1, 
    backgroundColor: 'rgba(0,0,0,0.5)', 
    justifyContent: 'center', 
    alignItems: 'center',
    padding: 24,
  },
  modalBackdrop: { 
    position: 'absolute', 
    top: 0, 
    left: 0, 
    right: 0, 
    bottom: 0,
  },
  modalContainer: { 
    backgroundColor: '#f5f5f5', 
    borderRadius: 16, 
    width: '95%',
    maxWidth: 1400,
    height: '95%',
    maxHeight: 950,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.3,
    shadowRadius: 20,
    elevation: 20,
  },
  header: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', padding: 16, backgroundColor: '#fff', borderBottomWidth: 1, borderBottomColor: '#ddd', borderTopLeftRadius: 16, borderTopRightRadius: 16 },
  headerTitle: { fontSize: 20, fontWeight: 'bold' },
  closeButton: { width: 36, height: 36, borderRadius: 18, backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#e2e8f0', justifyContent: 'center', alignItems: 'center' },
  closeButtonText: { color: '#64748b', fontSize: 18 },
  content: { flex: 1, padding: 16 },
  loadingText: { padding: 20, textAlign: 'center', color: '#666' },
  topSection: { flexDirection: 'row', backgroundColor: '#fff', borderRadius: 16, padding: 20, marginBottom: 16 },
  topLeft: { alignItems: 'center', marginRight: 20 },
  photoContainer: { width: 120, height: 120, borderRadius: 60, overflow: 'hidden', marginBottom: 8, borderWidth: 3, borderColor: '#000' },
  photo: { width: '100%', height: '100%' },
  photoPlaceholder: { width: '100%', height: '100%', backgroundColor: '#eee', justifyContent: 'center', alignItems: 'center' },
  photoPlaceholderText: { color: '#999', fontSize: 16 },
  photoInput: { borderWidth: 1, borderColor: '#ddd', borderRadius: 8, padding: 8, fontSize: 12, width: 120, textAlign: 'center' },
  topCenter: { flex: 1, justifyContent: 'center' },
  playerFirstName: { fontSize: 28, color: '#666' },
  playerLastName: { fontSize: 36, fontWeight: 'bold', color: '#000' },
  ageRow: { flexDirection: 'row', alignItems: 'center', marginTop: 4 },
  ageText: { fontSize: 18, color: '#666' },
  birthdayIconLarge: { fontSize: 24, marginLeft: 8 },
  nameInput: { fontSize: 24, fontWeight: 'bold', borderBottomWidth: 2, borderBottomColor: '#000', marginBottom: 8, padding: 4 },
  tmInputTop: { fontSize: 14, borderWidth: 1, borderColor: '#ddd', borderRadius: 8, padding: 8, marginTop: 8 },
  topRight: { alignItems: 'center', justifyContent: 'center' },
  clubSection: { alignItems: 'center' },
  clubLogoHeader: { width: 80, height: 80, resizeMode: 'contain', marginBottom: 8 },
  clubNameHeaderNoLogo: { fontSize: 16, fontWeight: '600', textAlign: 'center', maxWidth: 120 },
  clubTextRed: { color: '#dc3545' },
  futureClubHeader: { flexDirection: 'row', alignItems: 'center', marginTop: 8 },
  greenArrow: { fontSize: 24, color: '#28a745', fontWeight: 'bold', marginRight: 8 },
  futureClubLogoHeader: { width: 40, height: 40, resizeMode: 'contain' },
  futureClubNameHeader: { fontSize: 14, color: '#28a745', fontWeight: '500' },
  tmButton: { marginTop: 12 },
  transfermarktIcon: { width: 40, height: 40, resizeMode: 'contain' },
  twoColumnContainer: { flexDirection: 'row', gap: 16 },
  halfColumn: { flex: 1 },
  card: { backgroundColor: '#fff', borderRadius: 16, padding: 20, marginBottom: 16 },
  cardFullWidth: { backgroundColor: '#fff', borderRadius: 16, padding: 20, marginBottom: 16 },
  cardTitle: { fontSize: 18, fontWeight: '700', color: '#1a1a1a', marginBottom: 16, borderBottomWidth: 2, borderBottomColor: '#f0f0f0', paddingBottom: 12 },
  infoRow: { marginBottom: 12 },
  label: { fontSize: 13, color: '#999', marginBottom: 4 },
  value: { fontSize: 15, color: '#333' },
  input: { borderWidth: 1, borderColor: '#ddd', borderRadius: 8, padding: 12, fontSize: 15, backgroundColor: '#fff' },
  smallTextArea: { minHeight: 60 },
  textArea: { minHeight: 100 },
  splitContainer: { flexDirection: 'row', gap: 20 },
  splitColumn: { flex: 1 },
  familyContainer: { flexDirection: 'row', gap: 20 },
  familyColumn: { flex: 1 },
  sectionSubtitle: { fontSize: 14, fontWeight: '600', color: '#666', marginBottom: 8, marginTop: 8 },
  chipGrid: { flexDirection: 'row', flexWrap: 'wrap', gap: 6 },
  chip: { paddingVertical: 8, paddingHorizontal: 12, borderRadius: 20, backgroundColor: '#f0f0f0', borderWidth: 1, borderColor: '#ddd' },
  chipSelected: { backgroundColor: '#000', borderColor: '#000' },
  chipText: { fontSize: 13, color: '#333' },
  chipTextSelected: { color: '#fff' },
  dropdownButton: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', borderWidth: 1, borderColor: '#ddd', borderRadius: 8, padding: 12 },
  dropdownButtonText: { fontSize: 15, color: '#333' },
  pickerList: { borderWidth: 1, borderColor: '#ddd', borderRadius: 8, marginTop: 4, maxHeight: 200 },
  pickerScroll: { maxHeight: 200 },
  pickerItem: { padding: 12, borderBottomWidth: 1, borderBottomColor: '#eee' },
  pickerItemSelected: { backgroundColor: '#000' },
  pickerItemText: { fontSize: 14, color: '#333' },
  pickerItemTextSelected: { color: '#fff' },
  footSelector: { flexDirection: 'row', gap: 8 },
  footOption: { flex: 1, padding: 12, borderRadius: 8, backgroundColor: '#f0f0f0', alignItems: 'center' },
  footOptionSelected: { backgroundColor: '#000' },
  footOptionText: { fontSize: 14, color: '#333' },
  footOptionTextSelected: { color: '#fff' },
  statusBadge: { paddingVertical: 6, paddingHorizontal: 12, borderRadius: 8, alignSelf: 'flex-start' },
  statusBadgeNormal: { backgroundColor: '#e9ecef' },
  statusBadgeGreen: { backgroundColor: '#d4edda' },
  statusBadgeRed: { backgroundColor: '#f8d7da' },
  statusBadgeText: { fontSize: 14, fontWeight: '600' },
  statusTextNormal: { color: '#495057' },
  statusTextGreen: { color: '#155724' },
  statusTextRed: { color: '#721c24' },
  listingBadge: { paddingVertical: 6, paddingHorizontal: 12, borderRadius: 8, alignSelf: 'flex-start' },
  listingKMH: { backgroundColor: '#000' },
  listingPM: { backgroundColor: '#5bc0de' },
  listingBadgeText: { color: '#fff', fontSize: 14, fontWeight: '600' },
  clubRowSmall: { flexDirection: 'row', alignItems: 'center' },
  clubLogoSmall: { width: 24, height: 24, resizeMode: 'contain', marginRight: 8 },
  birthdayRow: { flexDirection: 'row', alignItems: 'center' },
  birthdayIcon: { fontSize: 16, marginLeft: 8 },
  phoneContainer: { flexDirection: 'row', gap: 8 },
  phoneCodePicker: { width: 120 },
  phoneInput: { flex: 1 },
  addressRow: { flexDirection: 'row', gap: 8 },
  addressStreet: { flex: 2 },
  addressPLZ: { flex: 0.5, minWidth: 70 },
  addressCity: { flex: 1 },
  socialIconsRow: { flexDirection: 'row', gap: 12 },
  socialIcon: { width: 28, height: 28, resizeMode: 'contain' },
  socialInputRow: { flexDirection: 'row', alignItems: 'center', marginBottom: 8 },
  socialIconSmall: { width: 24, height: 24, resizeMode: 'contain', marginRight: 8 },
  socialInput: { flex: 1 },
  futureContractRow: { flexDirection: 'row', alignItems: 'center', gap: 8, marginTop: 8 },
  smallLabel: { fontSize: 12, color: '#666' },
  uploadButton: { paddingVertical: 6, paddingHorizontal: 12, backgroundColor: '#000', borderRadius: 6, alignSelf: 'flex-start', marginBottom: 8 },
  uploadButtonText: { color: '#fff', fontSize: 12, fontWeight: '600' },
  smallUploadButton: { paddingVertical: 6, paddingHorizontal: 12, backgroundColor: '#000', borderRadius: 6, alignSelf: 'flex-start', marginTop: 6 },
  smallUploadButtonText: { color: '#fff', fontSize: 12, fontWeight: '600' },
  documentList: { marginTop: 8 },
  documentItem: { flexDirection: 'row', alignItems: 'center', backgroundColor: '#f8f8f8', padding: 10, borderRadius: 8, marginBottom: 6 },
  documentLink: { flexDirection: 'row', alignItems: 'center', flex: 1 },
  documentIcon: { fontSize: 18, marginRight: 8 },
  documentName: { fontSize: 14, color: '#333' },
  documentDelete: { padding: 4 },
  documentDeleteText: { color: '#ff4444', fontSize: 16, fontWeight: 'bold' },
  smallDocItem: { flexDirection: 'row', alignItems: 'center', backgroundColor: '#f8f8f8', padding: 6, borderRadius: 6, marginTop: 4 },
  smallDocName: { fontSize: 12, color: '#333', flex: 1 },
  docLink: { fontSize: 13, color: '#007bff', marginTop: 4 },
  bottomButtons: { flexDirection: 'row', padding: 16, backgroundColor: '#fff', borderTopWidth: 1, borderTopColor: '#e2e8f0', justifyContent: 'flex-end', gap: 8 },
  deleteButton: { backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#ef4444', paddingVertical: 12, paddingHorizontal: 16, borderRadius: 10, marginRight: 'auto' },
  deleteButtonText: { color: '#ef4444', fontSize: 16, fontWeight: '600' },
  editButton: { backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#64748b', paddingVertical: 12, paddingHorizontal: 24, borderRadius: 10 },
  editButtonText: { color: '#64748b', fontSize: 16, fontWeight: '600' },
  cancelButton: { backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#e2e8f0', paddingVertical: 12, paddingHorizontal: 16, borderRadius: 10 },
  cancelButtonText: { color: '#64748b', fontSize: 16, fontWeight: '600' },
  saveButton: { backgroundColor: '#f8fafc', borderWidth: 1, borderColor: '#10b981', paddingVertical: 12, paddingHorizontal: 24, borderRadius: 10 },
  saveButtonText: { color: '#10b981', fontSize: 16, fontWeight: '600' },
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', alignItems: 'center' },
  modalContent: { backgroundColor: '#fff', borderRadius: 16, padding: 24, width: '90%', maxWidth: 400 },
  modalTitle: { fontSize: 20, fontWeight: 'bold', marginBottom: 12, textAlign: 'center' },
  modalText: { fontSize: 16, color: '#333', textAlign: 'center', marginBottom: 20 },
  modalButtons: { flexDirection: 'row', justifyContent: 'space-between' },
  modalCancelButton: { flex: 1, padding: 14, borderRadius: 8, backgroundColor: '#eee', marginRight: 8, alignItems: 'center' },
  modalCancelButtonText: { color: '#666', fontWeight: '600' },
  modalDeleteButton: { flex: 1, padding: 14, borderRadius: 8, backgroundColor: '#ff4444', marginLeft: 8, alignItems: 'center' },
  modalDeleteButtonText: { color: '#fff', fontWeight: '600' },
  autocompleteContainer: { position: 'relative' },
  clubInputRow: { flexDirection: 'row', alignItems: 'center' },
  clubLogoInput: { width: 28, height: 28, resizeMode: 'contain', marginRight: 8 },
  clubInput: { flex: 1 },
  suggestionsList: { 
    position: 'absolute', 
    top: '100%', 
    left: 0, 
    right: 0, 
    backgroundColor: '#fff', 
    borderWidth: 2, 
    borderColor: '#000', 
    borderRadius: 8, 
    maxHeight: 200, 
    zIndex: 9999,
    shadowColor: '#000', 
    shadowOffset: { width: 0, height: 4 }, 
    shadowOpacity: 0.3, 
    shadowRadius: 8, 
    elevation: 10,
  },
  suggestionsScroll: { maxHeight: 200 },
  suggestionItem: { 
    padding: 14, 
    borderBottomWidth: 1, 
    borderBottomColor: '#eee',
    backgroundColor: '#fff',
  },
  suggestionText: { fontSize: 15, color: '#000', fontWeight: '500' },
  // Spielplan Button Styles
  spielplanButton: {
    backgroundColor: '#f0f0f0',
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#ddd',
  },
  spielplanButtonText: {
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
  },
  spielplanHint: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
    fontStyle: 'italic',
  },
  valueGray: {
    fontSize: 15,
    color: '#999',
    fontStyle: 'italic',
  },
});
// fussballDeApi.ts - Integration mit api-fussball.de
// Holt Spielpl√§ne von fussball.de √ºber die kostenlose API

import { SupabaseClient } from '@supabase/supabase-js';

// Nutze lokalen Proxy um CORS zu umgehen
// Proxy l√§uft auf localhost:3001 und leitet an api-fussball.de weiter
const USE_PROXY = true;
const PROXY_URL = 'http://localhost:3001/proxy';
const DIRECT_URL = 'https://api-fussball.de/api';
const API_BASE_URL = USE_PROXY ? `${PROXY_URL}/api` : DIRECT_URL;

// Typen
export interface ApiGame {
  id: string;
  date: string;
  time: string;
  homeTeam: string;
  awayTeam: string;
  homeTeamLogo?: string;
  awayTeamLogo?: string;
  location?: string;
  league?: string;
  matchday?: string;
  result?: string;
}

export interface PlayerWithGames {
  id: string;
  first_name: string;
  last_name: string;
  club: string;
  league: string;
  fussball_de_url: string;
  team_id: string;
  responsibility?: string;
  games: ApiGame[];
}

export interface SyncResult {
  success: boolean;
  added: number;
  updated: number;
  errors: string[];
}

// Team-ID aus fussball.de URL extrahieren
export function extractTeamId(fussballDeUrl: string): string | null {
  if (!fussballDeUrl) return null;
  
  // URL Format: https://www.fussball.de/mannschaft/[name]/[...]/team-id/[TEAM_ID]
  // Oder: /mannschaft/[...]/team-id/[TEAM_ID]
  
  const teamIdMatch = fussballDeUrl.match(/team-id\/([A-Z0-9]+)/i);
  if (teamIdMatch) {
    return teamIdMatch[1];
  }
  
  // Alternativ: ID am Ende der URL
  const altMatch = fussballDeUrl.match(/\/([A-Z0-9]{20,})(?:\?|#|$)/i);
  if (altMatch) {
    return altMatch[1];
  }
  
  return null;
}

// Deutsches Datum "Sa, 25.10.2025" oder "25.10.2025" in ISO-Format "2025-10-25" umwandeln
function convertGermanDateToISO(germanDate: string): string {
  if (!germanDate) return '';
  
  // Bereits im ISO-Format?
  if (/^\d{4}-\d{2}-\d{2}$/.test(germanDate)) {
    return germanDate;
  }
  
  // Entferne Wochentag falls vorhanden (z.B. "Sa, " oder "So, ")
  const cleanDate = germanDate.replace(/^[A-Za-z]{2},?\s*/, '');
  
  // Format: DD.MM.YYYY
  const match = cleanDate.match(/(\d{1,2})\.(\d{1,2})\.(\d{4})/);
  if (match) {
    const day = match[1].padStart(2, '0');
    const month = match[2].padStart(2, '0');
    const year = match[3];
    return `${year}-${month}-${day}`;
  }
  
  // Format: DD.MM.YY
  const shortMatch = cleanDate.match(/(\d{1,2})\.(\d{1,2})\.(\d{2})/);
  if (shortMatch) {
    const day = shortMatch[1].padStart(2, '0');
    const month = shortMatch[2].padStart(2, '0');
    const year = parseInt(shortMatch[3]) > 50 ? `19${shortMatch[3]}` : `20${shortMatch[3]}`;
    return `${year}-${month}-${day}`;
  }
  
  console.warn('Konnte Datum nicht konvertieren:', germanDate);
  return '';
}

// API Token aus Supabase laden (settings Tabelle)
export async function getApiToken(supabase: SupabaseClient): Promise<string | null> {
  try {
    const { data, error } = await supabase
      .from('app_settings')
      .select('value')
      .eq('key', 'fussball_de_api_token')
      .single();
    
    if (error || !data) {
      console.log('Kein API Token gefunden');
      return null;
    }
    
    return data.value;
  } catch (err) {
    console.error('Fehler beim Laden des API Tokens:', err);
    return null;
  }
}

// API Token in Supabase speichern
export async function saveApiToken(supabase: SupabaseClient, token: string): Promise<boolean> {
  try {
    const { error } = await supabase
      .from('app_settings')
      .upsert({ 
        key: 'fussball_de_api_token', 
        value: token,
        updated_at: new Date().toISOString()
      }, { 
        onConflict: 'key' 
      });
    
    return !error;
  } catch (err) {
    console.error('Fehler beim Speichern des API Tokens:', err);
    return false;
  }
}

// N√§chste Spiele eines Teams von der API holen
export async function fetchTeamNextGames(teamId: string, token: string): Promise<ApiGame[]> {
  try {
    const response = await fetch(`${API_BASE_URL}/team/next_games/${teamId}`, {
      method: 'GET',
      headers: {
        'x-auth-token': token,
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      console.error(`API Fehler: ${response.status} ${response.statusText}`);
      return [];
    }
    
    const result = await response.json();
    console.log('API Response f√ºr Team', teamId, ':', result);
    
    if (!result.success || !result.data) {
      console.error('API Response nicht erfolgreich:', result);
      return [];
    }
    
    // API Response in unser Format umwandeln
    const games: ApiGame[] = result.data.map((game: any) => {
      // Datum konvertieren
      const rawDate = game.date || game.datum || '';
      const isoDate = convertGermanDateToISO(rawDate);
      
      console.log('Datum Konvertierung:', rawDate, '->', isoDate);
      
      return {
        id: game.id || `${isoDate}_${game.homeTeam || game.home}_${game.awayTeam || game.away}`.replace(/\s/g, '_'),
        date: isoDate,
        time: game.time || game.uhrzeit || '',
        homeTeam: game.homeTeam || game.heimmannschaft || game.home || '',
        awayTeam: game.awayTeam || game.gastmannschaft || game.away || '',
        homeTeamLogo: game.homeLogo || game.homeTeamLogo || game.heimLogo || null,
        awayTeamLogo: game.awayLogo || game.awayTeamLogo || game.gastLogo || null,
        location: game.location || game.ort || game.spielort || '',
        league: game.competition || game.league || game.liga || game.wettbewerb || '',
        matchday: game.matchday || game.spieltag || '',
        result: game.result || game.ergebnis || null
      };
    }).filter((game: ApiGame) => game.date); // Nur Spiele mit g√ºltigem Datum
    
    return games;
  } catch (err) {
    console.error('Fehler beim Abrufen der Spiele:', err);
    return [];
  }
}

// Alle Spieler mit fussball_de_url laden
export async function getPlayersWithFussballDeUrl(supabase: SupabaseClient): Promise<any[]> {
  const { data, error } = await supabase
    .from('player_details')
    .select('id, first_name, last_name, club, league, fussball_de_url, responsibility')
    .not('fussball_de_url', 'is', null)
    .neq('fussball_de_url', '');
  
  if (error) {
    console.error('Fehler beim Laden der Spieler:', error);
    return [];
  }
  
  return data || [];
}

// Spiele in die Datenbank speichern/aktualisieren
export async function saveGamesToDatabase(
  supabase: SupabaseClient, 
  playerId: string, 
  playerName: string,
  games: ApiGame[]
): Promise<{ added: number; updated: number }> {
  let added = 0;
  let updated = 0;
  
  for (const game of games) {
    // √úberspringe Spiele ohne g√ºltiges Datum
    if (!game.date || game.date.length !== 10) {
      console.warn('√úberspringe Spiel ohne g√ºltiges Datum:', game);
      continue;
    }
    
    try {
      // Pr√ºfen ob Spiel bereits existiert (basierend auf Datum + Teams)
      const { data: existing } = await supabase
        .from('player_games')
        .select('id')
        .eq('player_id', playerId)
        .eq('date', game.date)
        .eq('home_team', game.homeTeam)
        .eq('away_team', game.awayTeam)
        .maybeSingle();
      
      const gameData = {
        player_id: playerId,
        player_name: playerName,
        date: game.date,
        time: game.time || null,
        home_team: game.homeTeam,
        away_team: game.awayTeam,
        home_team_logo: game.homeTeamLogo || null,
        away_team_logo: game.awayTeamLogo || null,
        location: game.location || null,
        league: game.league || null,
        matchday: game.matchday || null,
        result: game.result || null,
        source: 'api-fussball.de',
        updated_at: new Date().toISOString()
      };
      
      if (existing) {
        // Update
        const { error } = await supabase
          .from('player_games')
          .update(gameData)
          .eq('id', existing.id);
        
        if (error) {
          console.error('Update Fehler:', error);
        } else {
          updated++;
        }
      } else {
        // Insert
        const { error } = await supabase
          .from('player_games')
          .insert([{ 
            ...gameData, 
            selected: false,
            created_at: new Date().toISOString() 
          }]);
        
        if (error) {
          console.error('Insert Fehler:', error, 'Daten:', gameData);
        } else {
          added++;
        }
      }
    } catch (err) {
      console.error('Fehler beim Speichern:', err);
    }
  }
  
  return { added, updated };
}

// Hauptfunktion: Alle Spieler-Spiele synchronisieren
export async function syncAllPlayerGames(
  supabase: SupabaseClient,
  onProgress?: (current: number, total: number, playerName: string) => void
): Promise<SyncResult> {
  const result: SyncResult = {
    success: false,
    added: 0,
    updated: 0,
    errors: []
  };
  
  // API Token laden
  const token = await getApiToken(supabase);
  if (!token) {
    result.errors.push('Kein API Token konfiguriert. Bitte Token in Einstellungen hinterlegen.');
    return result;
  }
  
  // Spieler laden
  const players = await getPlayersWithFussballDeUrl(supabase);
  if (players.length === 0) {
    result.errors.push('Keine Spieler mit fussball.de URL gefunden.');
    return result;
  }
  
  console.log(`Synchronisiere ${players.length} Spieler...`);
  
  // F√ºr jeden Spieler Spiele laden
  for (let i = 0; i < players.length; i++) {
    const player = players[i];
    const playerName = `${player.first_name} ${player.last_name}`;
    
    if (onProgress) {
      onProgress(i + 1, players.length, playerName);
    }
    
    // Team-ID extrahieren
    const teamId = extractTeamId(player.fussball_de_url);
    if (!teamId) {
      result.errors.push(`${playerName}: Keine Team-ID in URL gefunden`);
      console.error(`Keine Team-ID f√ºr ${playerName}:`, player.fussball_de_url);
      continue;
    }
    
    console.log(`Lade Spiele f√ºr ${playerName} (Team: ${teamId})...`);
    
    // Spiele von API holen
    const games = await fetchTeamNextGames(teamId, token);
    console.log(`${games.length} Spiele f√ºr ${playerName} gefunden`);
    
    if (games.length === 0) {
      // Kein Fehler, vielleicht einfach keine Spiele
      continue;
    }
    
    // Spiele speichern
    const saveResult = await saveGamesToDatabase(supabase, player.id, playerName, games);
    result.added += saveResult.added;
    result.updated += saveResult.updated;
    
    console.log(`${playerName}: ${saveResult.added} neu, ${saveResult.updated} aktualisiert`);
    
    // Kurze Pause um API nicht zu √ºberlasten
    await new Promise(resolve => setTimeout(resolve, 500));
  }
  
  result.success = true;
  return result;
}

// Spiele eines einzelnen Spielers laden
export async function syncPlayerGames(
  supabase: SupabaseClient,
  playerId: string,
  fussballDeUrl: string,
  playerName: string
): Promise<{ success: boolean; games: ApiGame[]; error?: string }> {
  const token = await getApiToken(supabase);
  if (!token) {
    return { success: false, games: [], error: 'Kein API Token' };
  }
  
  const teamId = extractTeamId(fussballDeUrl);
  if (!teamId) {
    return { success: false, games: [], error: 'Keine Team-ID in URL' };
  }
  
  const games = await fetchTeamNextGames(teamId, token);
  
  if (games.length > 0) {
    await saveGamesToDatabase(supabase, playerId, playerName, games);
  }
  
  return { success: true, games };
}

// Alle gespeicherten Spiele laden (f√ºr die n√§chsten 8 Wochen)
export async function loadUpcomingGames(supabase: SupabaseClient): Promise<any[]> {
  const today = new Date();
  const in8Weeks = new Date();
  in8Weeks.setDate(in8Weeks.getDate() + 56); // 8 Wochen
  
  const { data, error } = await supabase
    .from('player_games')
    .select(`
      *,
      player:player_details(id, first_name, last_name, club, responsibility)
    `)
    .gte('date', today.toISOString().split('T')[0])
    .lte('date', in8Weeks.toISOString().split('T')[0])
    .order('date', { ascending: true });
  
  if (error) {
    console.error('Fehler beim Laden der Spiele:', error);
    return [];
  }
  
  return data || [];
}

// L√∂sche alte Spiele (√§lter als 1 Tag)
export async function cleanupOldGames(supabase: SupabaseClient): Promise<number> {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  
  const { data, error } = await supabase
    .from('player_games')
    .delete()
    .lt('date', yesterday.toISOString().split('T')[0])
    .select('id');
  
  if (error) {
    console.error('Fehler beim L√∂schen alter Spiele:', error);
    return 0;
  }
  
  return data?.length || 0;
}
